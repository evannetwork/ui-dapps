(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("dapp-browser"));
	else if(typeof define === 'function' && define.amd)
		define("i18n.vuex.libs.js", ["dapp-browser"], factory);
	else if(typeof exports === 'object')
		exports["i18n.vuex.libs.js"] = factory(require("dapp-browser"));
	else
		root["i18n.vuex.libs.js"] = factory(root["dapp-browser"]);
})(window, function(__WEBPACK_EXTERNAL_MODULE_dapp_browser__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/dist/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../node_modules/vuex-i18n/dist/vuex-i18n.es.js":
/*!*******************************************************************************************************!*\
  !*** /Users/tschuck/projects/evan.network/ui/ui-vue-core/node_modules/vuex-i18n/dist/vuex-i18n.es.js ***!
  \*******************************************************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\nfunction _typeof(obj) {\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function (obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function (obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\n/* vuex-i18n-store defines a vuex module to store locale translations. Make sure\n** to also include the file vuex-i18n.js to enable easy access to localized\n** strings in your vue components.\n*/\n// define a simple vuex module to handle locale translations\nvar i18nVuexModule = {\n  namespaced: true,\n  state: {\n    locale: null,\n    fallback: null,\n    translations: {}\n  },\n  mutations: {\n    // set the current locale\n    SET_LOCALE: function SET_LOCALE(state, payload) {\n      state.locale = payload.locale;\n    },\n    // add a new locale\n    ADD_LOCALE: function ADD_LOCALE(state, payload) {\n      // reduce the given translations to a single-depth tree\n      var translations = flattenTranslations(payload.translations);\n\n      if (state.translations.hasOwnProperty(payload.locale)) {\n        // get the existing translations\n        var existingTranslations = state.translations[payload.locale]; // merge the translations\n\n        state.translations[payload.locale] = Object.assign({}, existingTranslations, translations);\n      } else {\n        // just set the locale if it does not yet exist\n        state.translations[payload.locale] = translations;\n      } // make sure to notify vue of changes (this might break with new vue versions)\n\n\n      try {\n        if (state.translations.__ob__) {\n          state.translations.__ob__.dep.notify();\n        }\n      } catch (ex) {}\n    },\n    // replace existing locale information with new translations\n    REPLACE_LOCALE: function REPLACE_LOCALE(state, payload) {\n      // reduce the given translations to a single-depth tree\n      var translations = flattenTranslations(payload.translations); // replace the translations entirely\n\n      state.translations[payload.locale] = translations; // make sure to notify vue of changes (this might break with new vue versions)\n\n      try {\n        if (state.translations.__ob__) {\n          state.translations.__ob__.dep.notify();\n        }\n      } catch (ex) {}\n    },\n    // remove a locale from the store\n    REMOVE_LOCALE: function REMOVE_LOCALE(state, payload) {\n      // check if the given locale is present in the state\n      if (state.translations.hasOwnProperty(payload.locale)) {\n        // check if the current locale is the given locale to remvoe\n        if (state.locale === payload.locale) {\n          // reset the current locale\n          state.locale = null;\n        } // create a copy of the translations object\n\n\n        var translationCopy = Object.assign({}, state.translations); // remove the given locale\n\n        delete translationCopy[payload.locale]; // set the state to the new object\n\n        state.translations = translationCopy;\n      }\n    },\n    SET_FALLBACK_LOCALE: function SET_FALLBACK_LOCALE(state, payload) {\n      state.fallback = payload.locale;\n    }\n  },\n  actions: {\n    // set the current locale\n    setLocale: function setLocale(context, payload) {\n      context.commit({\n        type: 'SET_LOCALE',\n        locale: payload.locale\n      });\n    },\n    // add or extend a locale with translations\n    addLocale: function addLocale(context, payload) {\n      context.commit({\n        type: 'ADD_LOCALE',\n        locale: payload.locale,\n        translations: payload.translations\n      });\n    },\n    // replace locale information\n    replaceLocale: function replaceLocale(context, payload) {\n      context.commit({\n        type: 'REPLACE_LOCALE',\n        locale: payload.locale,\n        translations: payload.translations\n      });\n    },\n    // remove the given locale translations\n    removeLocale: function removeLocale(context, payload) {\n      context.commit({\n        type: 'REMOVE_LOCALE',\n        locale: payload.locale,\n        translations: payload.translations\n      });\n    },\n    setFallbackLocale: function setFallbackLocale(context, payload) {\n      context.commit({\n        type: 'SET_FALLBACK_LOCALE',\n        locale: payload.locale\n      });\n    }\n  }\n}; // flattenTranslations will convert object trees for translations into a\n// single-depth object tree\n\nvar flattenTranslations = function flattenTranslations(translations) {\n  var toReturn = {};\n\n  for (var i in translations) {\n    // check if the property is present\n    if (!translations.hasOwnProperty(i)) {\n      continue;\n    } // get the type of the property\n\n\n    var objType = _typeof(translations[i]); // allow unflattened array of strings\n\n\n    if (isArray(translations[i])) {\n      var count = translations[i].length;\n\n      for (var index = 0; index < count; index++) {\n        var itemType = _typeof(translations[i][index]);\n\n        if (itemType !== 'string') {\n          console.warn('i18n:', 'currently only arrays of strings are fully supported', translations[i]);\n          break;\n        }\n      }\n\n      toReturn[i] = translations[i];\n    } else if (objType == 'object' && objType !== null) {\n      var flatObject = flattenTranslations(translations[i]);\n\n      for (var x in flatObject) {\n        if (!flatObject.hasOwnProperty(x)) continue;\n        toReturn[i + '.' + x] = flatObject[x];\n      }\n    } else {\n      toReturn[i] = translations[i];\n    }\n  }\n\n  return toReturn;\n}; // check if the given object is an array\n\n\nfunction isArray(obj) {\n  return !!obj && Array === obj.constructor;\n}\n\nvar plurals = {\n  getTranslationIndex: function getTranslationIndex(languageCode, n) {\n    switch (languageCode) {\n      case 'ay': // Aymará\n\n      case 'bo': // Tibetan\n\n      case 'cgg': // Chiga\n\n      case 'dz': // Dzongkha\n\n      case 'fa': // Persian\n\n      case 'id': // Indonesian\n\n      case 'ja': // Japanese\n\n      case 'jbo': // Lojban\n\n      case 'ka': // Georgian\n\n      case 'kk': // Kazakh\n\n      case 'km': // Khmer\n\n      case 'ko': // Korean\n\n      case 'ky': // Kyrgyz\n\n      case 'lo': // Lao\n\n      case 'ms': // Malay\n\n      case 'my': // Burmese\n\n      case 'sah': // Yakut\n\n      case 'su': // Sundanese\n\n      case 'th': // Thai\n\n      case 'tt': // Tatar\n\n      case 'ug': // Uyghur\n\n      case 'vi': // Vietnamese\n\n      case 'wo': // Wolof\n\n      case 'zh':\n        // Chinese\n        // 1 form\n        return 0;\n\n      case 'is':\n        // Icelandic\n        // 2 forms\n        return n % 10 !== 1 || n % 100 === 11 ? 1 : 0;\n\n      case 'jv':\n        // Javanese\n        // 2 forms\n        return n !== 0 ? 1 : 0;\n\n      case 'mk':\n        // Macedonian\n        // 2 forms\n        return n === 1 || n % 10 === 1 ? 0 : 1;\n\n      case 'ach': // Acholi\n\n      case 'ak': // Akan\n\n      case 'am': // Amharic\n\n      case 'arn': // Mapudungun\n\n      case 'br': // Breton\n\n      case 'fil': // Filipino\n\n      case 'fr': // French\n\n      case 'gun': // Gun\n\n      case 'ln': // Lingala\n\n      case 'mfe': // Mauritian Creole\n\n      case 'mg': // Malagasy\n\n      case 'mi': // Maori\n\n      case 'oc': // Occitan\n\n      case 'pt_BR': // Brazilian Portuguese\n\n      case 'tg': // Tajik\n\n      case 'ti': // Tigrinya\n\n      case 'tr': // Turkish\n\n      case 'uz': // Uzbek\n\n      case 'wa': // Walloon\n\n      /* eslint-disable */\n\n      /* Disable \"Duplicate case label\" because there are 2 forms of Chinese plurals */\n\n      case 'zh':\n        // Chinese\n\n        /* eslint-enable */\n        // 2 forms\n        return n > 1 ? 1 : 0;\n\n      case 'lv':\n        // Latvian\n        // 3 forms\n        return n % 10 === 1 && n % 100 !== 11 ? 0 : n !== 0 ? 1 : 2;\n\n      case 'lt':\n        // Lithuanian\n        // 3 forms\n        return n % 10 === 1 && n % 100 !== 11 ? 0 : n % 10 >= 2 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n\n      case 'be': // Belarusian\n\n      case 'bs': // Bosnian\n\n      case 'hr': // Croatian\n\n      case 'ru': // Russian\n\n      case 'sr': // Serbian\n\n      case 'uk':\n        // Ukrainian\n        // 3 forms\n        return n % 10 === 1 && n % 100 !== 11 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n\n      case 'mnk':\n        // Mandinka\n        // 3 forms\n        return n === 0 ? 0 : n === 1 ? 1 : 2;\n\n      case 'ro':\n        // Romanian\n        // 3 forms\n        return n === 1 ? 0 : n === 0 || n % 100 > 0 && n % 100 < 20 ? 1 : 2;\n\n      case 'pl':\n        // Polish\n        // 3 forms\n        return n === 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n\n      case 'cs': // Czech\n\n      case 'sk':\n        // Slovak\n        // 3 forms\n        return n === 1 ? 0 : n >= 2 && n <= 4 ? 1 : 2;\n\n      case 'csb':\n        // Kashubian\n        // 3 forms\n        return n === 1 ? 0 : n % 10 >= 2 && n % 10 <= 4 && (n % 100 < 10 || n % 100 >= 20) ? 1 : 2;\n\n      case 'sl':\n        // Slovenian\n        // 4 forms\n        return n % 100 === 1 ? 0 : n % 100 === 2 ? 1 : n % 100 === 3 || n % 100 === 4 ? 2 : 3;\n\n      case 'mt':\n        // Maltese\n        // 4 forms\n        return n === 1 ? 0 : n === 0 || n % 100 > 1 && n % 100 < 11 ? 1 : n % 100 > 10 && n % 100 < 20 ? 2 : 3;\n\n      case 'gd':\n        // Scottish Gaelic\n        // 4 forms\n        return n === 1 || n === 11 ? 0 : n === 2 || n === 12 ? 1 : n > 2 && n < 20 ? 2 : 3;\n\n      case 'cy':\n        // Welsh\n        // 4 forms\n        return n === 1 ? 0 : n === 2 ? 1 : n !== 8 && n !== 11 ? 2 : 3;\n\n      case 'kw':\n        // Cornish\n        // 4 forms\n        return n === 1 ? 0 : n === 2 ? 1 : n === 3 ? 2 : 3;\n\n      case 'ga':\n        // Irish\n        // 5 forms\n        return n === 1 ? 0 : n === 2 ? 1 : n > 2 && n < 7 ? 2 : n > 6 && n < 11 ? 3 : 4;\n\n      case 'ar':\n        // Arabic\n        // 6 forms\n        return n === 0 ? 0 : n === 1 ? 1 : n === 2 ? 2 : n % 100 >= 3 && n % 100 <= 10 ? 3 : n % 100 >= 11 ? 4 : 5;\n\n      default:\n        // Everything else\n        return n !== 1 ? 1 : 0;\n    }\n  }\n};\n\nvar VuexI18nPlugin = {}; // internationalization plugin for vue js using vuex\n\nVuexI18nPlugin.install = function install(Vue, store, config) {\n  // TODO: remove this block for next major update (API break)\n  if (typeof arguments[2] === 'string' || typeof arguments[3] === 'string') {\n    console.warn('i18n: Registering the plugin vuex-i18n with a string for `moduleName` or `identifiers` is deprecated. Use a configuration object instead.', 'https://github.com/dkfbasel/vuex-i18n#setup');\n    config = {\n      moduleName: arguments[2],\n      identifiers: arguments[3]\n    };\n  } // merge default options with user supplied options\n\n\n  config = Object.assign({\n    warnings: true,\n    moduleName: 'i18n',\n    identifiers: ['{', '}'],\n    preserveState: false,\n    translateFilterName: 'translate',\n    translateInFilterName: 'translateIn',\n    onTranslationNotFound: function onTranslationNotFound() {}\n  }, config); // define module name and identifiers as constants to prevent any changes\n\n  var moduleName = config.moduleName;\n  var identifiers = config.identifiers;\n  var translateFilterName = config.translateFilterName;\n  var translateInFilterName = config.translateInFilterName; // initialize the onTranslationNotFound function and make sure it is actually\n  // a function\n\n  var onTranslationNotFound = config.onTranslationNotFound;\n\n  if (typeof onTranslationNotFound !== 'function') {\n    console.error('i18n: i18n config option onTranslationNotFound must be a function');\n\n    onTranslationNotFound = function onTranslationNotFound() {};\n  } // register the i18n module in the vuex store\n  // preserveState can be used via configuration if server side rendering is used\n\n\n  store.registerModule(moduleName, i18nVuexModule, {\n    preserveState: config.preserveState\n  }); // check if the plugin was correctly initialized\n\n  if (store.state.hasOwnProperty(moduleName) === false) {\n    console.error('i18n: i18n vuex module is not correctly initialized. Please check the module name:', moduleName); // always return the key if module is not initialized correctly\n\n    Vue.prototype.$i18n = function (key) {\n      return key;\n    };\n\n    Vue.prototype.$getLanguage = function () {\n      return null;\n    };\n\n    Vue.prototype.$setLanguage = function () {\n      console.error('i18n: i18n vuex module is not correctly initialized');\n    };\n\n    return;\n  }\n\n  var render = renderFn(identifiers, config.warnings); // get localized string from store. note that we pass the arguments passed\n  // to the function directly to the translateInLanguage function\n\n  var translate = function $t() {\n    // get the current language from the store\n    var locale = store.state[moduleName].locale;\n    return translateInLanguage.apply(void 0, [locale].concat(Array.prototype.slice.call(arguments)));\n  }; // get localized string from store in a given language if available.\n  // there are two possible signatures for the function.\n  // we will check the arguments to make up the options passed.\n  // 1: locale, key, options, pluralization\n  // 2: locale, key, defaultValue, options, pluralization\n\n\n  var translateInLanguage = function translateInLanguage(locale) {\n    // read the function arguments\n    var args = arguments; // initialize options\n\n    var key = '';\n    var defaultValue = '';\n    var options = {};\n    var pluralization = null;\n    var count = args.length; // check if a default value was specified and fill options accordingly\n\n    if (count >= 3 && typeof args[2] === 'string') {\n      key = args[1];\n      defaultValue = args[2];\n\n      if (count > 3) {\n        options = args[3];\n      }\n\n      if (count > 4) {\n        pluralization = args[4];\n      }\n    } else {\n      key = args[1]; // default value was not specified and is therefore the same as the key\n\n      defaultValue = key;\n\n      if (count > 2) {\n        options = args[2];\n      }\n\n      if (count > 3) {\n        pluralization = args[3];\n      }\n    } // return the default value if the locale is not set (could happen on initialization)\n\n\n    if (!locale) {\n      if (config.warnings) console.warn('i18n: i18n locale is not set when trying to access translations:', key);\n      return defaultValue;\n    } // get the translations from the store\n\n\n    var translations = store.state[moduleName].translations; // get the last resort fallback from the store\n\n    var fallback = store.state[moduleName].fallback; // split locale by - to support partial fallback for regional locales\n    // like de-CH, en-UK\n\n    var localeRegional = locale.split('-'); // flag for translation to exist or not\n\n    var translationExists = true; // check if the language exists in the store. return the key if not\n\n    if (translations.hasOwnProperty(locale) === false) {\n      translationExists = false; // check if the key exists in the store. return the key if not\n    } else if (translations[locale].hasOwnProperty(key) === false) {\n      translationExists = false;\n    } // return the value from the store\n\n\n    if (translationExists === true) {\n      return render(locale, translations[locale][key], options, pluralization);\n    } // check if a regional locale translation would be available for the key\n    // i.e. de for de-CH\n\n\n    if (localeRegional.length > 1 && translations.hasOwnProperty(localeRegional[0]) === true && translations[localeRegional[0]].hasOwnProperty(key) === true) {\n      return render(localeRegional[0], translations[localeRegional[0]][key], options, pluralization);\n    } // invoke a method if a translation is not found\n\n\n    var asyncTranslation = onTranslationNotFound(locale, key, defaultValue); // resolve async translations by updating the store\n\n    if (asyncTranslation) {\n      Promise.resolve(asyncTranslation).then(function (value) {\n        var additionalTranslations = {};\n        additionalTranslations[key] = value;\n        addLocale(locale, additionalTranslations);\n      });\n    } // check if a vaild fallback exists in the store.\n    // return the default value if not\n\n\n    if (translations.hasOwnProperty(fallback) === false) {\n      return render(locale, defaultValue, options, pluralization);\n    } // check if the key exists in the fallback locale in the store.\n    // return the default value if not\n\n\n    if (translations[fallback].hasOwnProperty(key) === false) {\n      return render(fallback, defaultValue, options, pluralization);\n    }\n\n    return render(locale, translations[fallback][key], options, pluralization);\n  }; // add a filter function to translate in a given locale (i.e. {{ 'something' | translateIn('en') }})\n\n\n  var translateInLanguageFilter = function translateInLanguageFilter(key, locale) {\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    return translateInLanguage.apply(void 0, [locale, key].concat(args));\n  }; // check if the given key exists in the current locale\n\n\n  var checkKeyExists = function checkKeyExists(key) {\n    var scope = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'fallback';\n    // get the current language from the store\n    var locale = store.state[moduleName].locale;\n    var fallback = store.state[moduleName].fallback;\n    var translations = store.state[moduleName].translations; // check the current translation\n\n    if (translations.hasOwnProperty(locale) && translations[locale].hasOwnProperty(key)) {\n      return true;\n    }\n\n    if (scope == 'strict') {\n      return false;\n    } // check any localized translations\n\n\n    var localeRegional = locale.split('-');\n\n    if (localeRegional.length > 1 && translations.hasOwnProperty(localeRegional[0]) && translations[localeRegional[0]].hasOwnProperty(key)) {\n      return true;\n    }\n\n    if (scope == 'locale') {\n      return false;\n    } // check if a fallback locale exists\n\n\n    if (translations.hasOwnProperty(fallback) && translations[fallback].hasOwnProperty(key)) {\n      return true;\n    } // key does not exist in the store\n\n\n    return false;\n  }; // set fallback locale\n\n\n  var setFallbackLocale = function setFallbackLocale(locale) {\n    store.dispatch({\n      type: \"\".concat(moduleName, \"/setFallbackLocale\"),\n      locale: locale\n    });\n  }; // set the current locale\n\n\n  var setLocale = function setLocale(locale) {\n    store.dispatch({\n      type: \"\".concat(moduleName, \"/setLocale\"),\n      locale: locale\n    });\n  }; // get the current locale\n\n\n  var getLocale = function getLocale() {\n    return store.state[moduleName].locale;\n  }; // get all available locales\n\n\n  var getLocales = function getLocales() {\n    return Object.keys(store.state[moduleName].translations);\n  }; // add predefined translations to the store (keeping existing information)\n\n\n  var addLocale = function addLocale(locale, translations) {\n    return store.dispatch({\n      type: \"\".concat(moduleName, \"/addLocale\"),\n      locale: locale,\n      translations: translations\n    });\n  }; // replace all locale information in the store\n\n\n  var replaceLocale = function replaceLocale(locale, translations) {\n    return store.dispatch({\n      type: \"\".concat(moduleName, \"/replaceLocale\"),\n      locale: locale,\n      translations: translations\n    });\n  }; // remove the givne locale from the store\n\n\n  var removeLocale = function removeLocale(locale) {\n    if (store.state[moduleName].translations.hasOwnProperty(locale)) {\n      store.dispatch({\n        type: \"\".concat(moduleName, \"/removeLocale\"),\n        locale: locale\n      });\n    }\n  }; // we are phasing out the exists function\n\n\n  var phaseOutExistsFn = function phaseOutExistsFn(locale) {\n    if (config.warnings) console.warn('i18n: $i18n.exists is depreceated. Please use $i18n.localeExists instead. It provides exactly the same functionality.');\n    return checkLocaleExists(locale);\n  }; // check if the given locale is already loaded\n\n\n  var checkLocaleExists = function checkLocaleExists(locale) {\n    return store.state[moduleName].translations.hasOwnProperty(locale);\n  }; // register vue prototype methods\n\n\n  Vue.prototype.$i18n = {\n    locale: getLocale,\n    locales: getLocales,\n    set: setLocale,\n    add: addLocale,\n    replace: replaceLocale,\n    remove: removeLocale,\n    fallback: setFallbackLocale,\n    localeExists: checkLocaleExists,\n    keyExists: checkKeyExists,\n    translate: translate,\n    translateIn: translateInLanguage,\n    exists: phaseOutExistsFn\n  }; // register global methods\n\n  Vue.i18n = {\n    locale: getLocale,\n    locales: getLocales,\n    set: setLocale,\n    add: addLocale,\n    replace: replaceLocale,\n    remove: removeLocale,\n    fallback: setFallbackLocale,\n    translate: translate,\n    translateIn: translateInLanguage,\n    localeExists: checkLocaleExists,\n    keyExists: checkKeyExists,\n    exists: phaseOutExistsFn\n  }; // register the translation function on the vue instance directly\n\n  Vue.prototype.$t = translate; // register the specific language translation function on the vue instance directly\n\n  Vue.prototype.$tlang = translateInLanguage; // register a filter function for translations\n\n  Vue.filter(translateFilterName, translate);\n  Vue.filter(translateInFilterName, translateInLanguageFilter);\n}; // renderFn will initialize a function to render the variable substitutions in\n// the translation string. identifiers specify the tags will be used to find\n// variable substitutions, i.e. {test} or {{test}}, note that we are using a\n// closure to avoid recompilation of the regular expression to match tags on\n// every render cycle.\n\n\nvar renderFn = function renderFn(identifiers) {\n  var warnings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n  if (identifiers == null || identifiers.length != 2) {\n    console.warn('i18n: You must specify the start and end character identifying variable substitutions');\n  } // construct a regular expression ot find variable substitutions, i.e. {test}\n\n\n  var matcher = new RegExp('' + identifiers[0] + '{1}(\\\\w{1}|\\\\w.+?)' + identifiers[1] + '{1}', 'g'); // define the replacement function\n\n  var replace = function replace(translation, replacements) {\n    // check if the object has a replace property\n    if (!translation.replace) {\n      return translation;\n    }\n\n    return translation.replace(matcher, function (placeholder) {\n      // remove the identifiers (can be set on the module level)\n      var key = placeholder.replace(identifiers[0], '').replace(identifiers[1], '');\n\n      if (replacements[key] !== undefined) {\n        return replacements[key];\n      } // warn user that the placeholder has not been found\n\n\n      if (warnings) {\n        console.group ? console.group('i18n: Not all placeholders found') : console.warn('i18n: Not all placeholders found');\n        console.warn('Text:', translation);\n        console.warn('Placeholder:', placeholder);\n\n        if (console.groupEnd) {\n          console.groupEnd();\n        }\n      } // return the original placeholder\n\n\n      return placeholder;\n    });\n  }; // the render function will replace variable substitutions and prepare the\n  // translations for rendering\n\n\n  var render = function render(locale, translation) {\n    var replacements = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var pluralization = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n\n    // get the type of the property\n    var objType = _typeof(translation);\n\n    var pluralizationType = _typeof(pluralization);\n\n    var resolvePlaceholders = function resolvePlaceholders() {\n      if (isArray$1(translation)) {\n        // replace the placeholder elements in all sub-items\n        return translation.map(function (item) {\n          return replace(item, replacements, false);\n        });\n      } else if (objType === 'string') {\n        return replace(translation, replacements, true);\n      }\n    }; // return translation item directly\n\n\n    if (pluralization === null) {\n      return resolvePlaceholders();\n    } // check if pluralization value is countable\n\n\n    if (pluralizationType !== 'number') {\n      if (warnings) console.warn('i18n: pluralization is not a number');\n      return resolvePlaceholders();\n    } // --- handle pluralizations ---\n    // replace all placeholders\n\n\n    var resolvedTranslation = resolvePlaceholders(); // initialize pluralizations\n\n    var pluralizations = null; // if translations are already an array and have more than one entry,\n    // we will not perform a split operation on :::\n\n    if (isArray$1(resolvedTranslation) && resolvedTranslation.length > 0) {\n      pluralizations = resolvedTranslation;\n    } else {\n      // split translation strings by ::: to find create the pluralization array\n      pluralizations = resolvedTranslation.split(':::');\n    } // determine the pluralization version to use by locale\n\n\n    var index = plurals.getTranslationIndex(locale, pluralization); // check if the specified index is present in the pluralization\n\n    if (typeof pluralizations[index] === 'undefined') {\n      if (warnings) {\n        console.warn('i18n: pluralization not provided in locale', translation, locale, index);\n      } // return the first element of the pluralization by default\n\n\n      return pluralizations[0].trim();\n    } // return the requested item from the pluralizations\n\n\n    return pluralizations[index].trim();\n  }; // return the render function to the caller\n\n\n  return render;\n}; // check if the given object is an array\n\n\nfunction isArray$1(obj) {\n  return !!obj && Array === obj.constructor;\n}\n\n// import the vuex module for localization\n\nvar index = {\n  store: i18nVuexModule,\n  plugin: VuexI18nPlugin\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (index);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pMThuLnZ1ZXgubGlicy5qcy8vVXNlcnMvdHNjaHVjay9wcm9qZWN0cy9ldmFuLm5ldHdvcmsvdWkvdWktdnVlLWNvcmUvbm9kZV9tb2R1bGVzL3Z1ZXgtaTE4bi9kaXN0L3Z1ZXgtaTE4bi5lcy5qcz8yMjZhIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNFQUFzRTs7QUFFdEUsNkRBQTZEO0FBQzdELE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTs7QUFFbkUsd0RBQXdEOztBQUV4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7OztBQUdULDhDQUE4QyxzQkFBc0I7O0FBRXBFLCtDQUErQzs7QUFFL0M7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTCwyQ0FBMkM7OztBQUczQztBQUNBOztBQUVBLHlCQUF5QixlQUFlO0FBQ3hDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3QkFBd0I7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOzs7QUFHSDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsS0FBSztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUcsVUFBVTs7QUFFYjtBQUNBO0FBQ0E7QUFDQSwyREFBMkQ7QUFDM0Q7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDs7O0FBR0E7QUFDQTtBQUNBLEdBQUcsRUFBRTs7QUFFTDtBQUNBLG9IQUFvSDs7QUFFcEg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxzREFBc0Q7QUFDdEQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSx5QkFBeUI7O0FBRXpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCOztBQUU1QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxvQkFBb0I7O0FBRXBCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTCw0REFBNEQ7O0FBRTVELG9EQUFvRDtBQUNwRDs7QUFFQSwyQ0FBMkM7O0FBRTNDLGlDQUFpQzs7QUFFakM7QUFDQSxnQ0FBZ0M7QUFDaEMsS0FBSztBQUNMO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQTtBQUNBLEtBQUs7QUFDTDs7O0FBR0E7QUFDQTtBQUNBLEtBQUs7OztBQUdMLDRFQUE0RTs7QUFFNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksaUVBQWlFLG1DQUFtQzs7O0FBR3hHO0FBQ0EsMEZBQTBGLGFBQWE7QUFDdkc7QUFDQTs7QUFFQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7O0FBRTVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0EsS0FBSzs7O0FBR0w7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSjtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBLElBQUk7OztBQUdKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUosK0JBQStCOztBQUUvQiw2Q0FBNkM7O0FBRTdDO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxpQ0FBaUMsS0FBSyxNQUFNLE1BQU07QUFDbEQ7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRyx5RUFBeUU7OztBQUc1RSxtREFBbUQsRUFBRSxLQUFLLEVBQUUsK0JBQStCLEVBQUUsUUFBUTs7QUFFckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87OztBQUdQO0FBQ0EsS0FBSztBQUNMLElBQUk7QUFDSjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBLE1BQU07OztBQUdOO0FBQ0E7QUFDQSxLQUFLOzs7QUFHTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7OztBQUdBLG9EQUFvRDs7QUFFcEQsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7OztBQUdMLG1FQUFtRTs7QUFFbkU7QUFDQTtBQUNBO0FBQ0EsT0FBTzs7O0FBR1A7QUFDQSxLQUFLOzs7QUFHTDtBQUNBLElBQUk7OztBQUdKO0FBQ0EsRUFBRTs7O0FBR0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVlLG9FQUFLLEVBQUMiLCJmaWxlIjoiLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZXgtaTE4bi9kaXN0L3Z1ZXgtaTE4bi5lcy5qcy5qcyIsInNvdXJjZXNDb250ZW50IjpbImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIikge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iajtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIF90eXBlb2YgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvYmouY29uc3RydWN0b3IgPT09IFN5bWJvbCAmJiBvYmogIT09IFN5bWJvbC5wcm90b3R5cGUgPyBcInN5bWJvbFwiIDogdHlwZW9mIG9iajtcbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIF90eXBlb2Yob2JqKTtcbn1cblxuLyogdnVleC1pMThuLXN0b3JlIGRlZmluZXMgYSB2dWV4IG1vZHVsZSB0byBzdG9yZSBsb2NhbGUgdHJhbnNsYXRpb25zLiBNYWtlIHN1cmVcbioqIHRvIGFsc28gaW5jbHVkZSB0aGUgZmlsZSB2dWV4LWkxOG4uanMgdG8gZW5hYmxlIGVhc3kgYWNjZXNzIHRvIGxvY2FsaXplZFxuKiogc3RyaW5ncyBpbiB5b3VyIHZ1ZSBjb21wb25lbnRzLlxuKi9cbi8vIGRlZmluZSBhIHNpbXBsZSB2dWV4IG1vZHVsZSB0byBoYW5kbGUgbG9jYWxlIHRyYW5zbGF0aW9uc1xudmFyIGkxOG5WdWV4TW9kdWxlID0ge1xuICBuYW1lc3BhY2VkOiB0cnVlLFxuICBzdGF0ZToge1xuICAgIGxvY2FsZTogbnVsbCxcbiAgICBmYWxsYmFjazogbnVsbCxcbiAgICB0cmFuc2xhdGlvbnM6IHt9XG4gIH0sXG4gIG11dGF0aW9uczoge1xuICAgIC8vIHNldCB0aGUgY3VycmVudCBsb2NhbGVcbiAgICBTRVRfTE9DQUxFOiBmdW5jdGlvbiBTRVRfTE9DQUxFKHN0YXRlLCBwYXlsb2FkKSB7XG4gICAgICBzdGF0ZS5sb2NhbGUgPSBwYXlsb2FkLmxvY2FsZTtcbiAgICB9LFxuICAgIC8vIGFkZCBhIG5ldyBsb2NhbGVcbiAgICBBRERfTE9DQUxFOiBmdW5jdGlvbiBBRERfTE9DQUxFKHN0YXRlLCBwYXlsb2FkKSB7XG4gICAgICAvLyByZWR1Y2UgdGhlIGdpdmVuIHRyYW5zbGF0aW9ucyB0byBhIHNpbmdsZS1kZXB0aCB0cmVlXG4gICAgICB2YXIgdHJhbnNsYXRpb25zID0gZmxhdHRlblRyYW5zbGF0aW9ucyhwYXlsb2FkLnRyYW5zbGF0aW9ucyk7XG5cbiAgICAgIGlmIChzdGF0ZS50cmFuc2xhdGlvbnMuaGFzT3duUHJvcGVydHkocGF5bG9hZC5sb2NhbGUpKSB7XG4gICAgICAgIC8vIGdldCB0aGUgZXhpc3RpbmcgdHJhbnNsYXRpb25zXG4gICAgICAgIHZhciBleGlzdGluZ1RyYW5zbGF0aW9ucyA9IHN0YXRlLnRyYW5zbGF0aW9uc1twYXlsb2FkLmxvY2FsZV07IC8vIG1lcmdlIHRoZSB0cmFuc2xhdGlvbnNcblxuICAgICAgICBzdGF0ZS50cmFuc2xhdGlvbnNbcGF5bG9hZC5sb2NhbGVdID0gT2JqZWN0LmFzc2lnbih7fSwgZXhpc3RpbmdUcmFuc2xhdGlvbnMsIHRyYW5zbGF0aW9ucyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBqdXN0IHNldCB0aGUgbG9jYWxlIGlmIGl0IGRvZXMgbm90IHlldCBleGlzdFxuICAgICAgICBzdGF0ZS50cmFuc2xhdGlvbnNbcGF5bG9hZC5sb2NhbGVdID0gdHJhbnNsYXRpb25zO1xuICAgICAgfSAvLyBtYWtlIHN1cmUgdG8gbm90aWZ5IHZ1ZSBvZiBjaGFuZ2VzICh0aGlzIG1pZ2h0IGJyZWFrIHdpdGggbmV3IHZ1ZSB2ZXJzaW9ucylcblxuXG4gICAgICB0cnkge1xuICAgICAgICBpZiAoc3RhdGUudHJhbnNsYXRpb25zLl9fb2JfXykge1xuICAgICAgICAgIHN0YXRlLnRyYW5zbGF0aW9ucy5fX29iX18uZGVwLm5vdGlmeSgpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChleCkge31cbiAgICB9LFxuICAgIC8vIHJlcGxhY2UgZXhpc3RpbmcgbG9jYWxlIGluZm9ybWF0aW9uIHdpdGggbmV3IHRyYW5zbGF0aW9uc1xuICAgIFJFUExBQ0VfTE9DQUxFOiBmdW5jdGlvbiBSRVBMQUNFX0xPQ0FMRShzdGF0ZSwgcGF5bG9hZCkge1xuICAgICAgLy8gcmVkdWNlIHRoZSBnaXZlbiB0cmFuc2xhdGlvbnMgdG8gYSBzaW5nbGUtZGVwdGggdHJlZVxuICAgICAgdmFyIHRyYW5zbGF0aW9ucyA9IGZsYXR0ZW5UcmFuc2xhdGlvbnMocGF5bG9hZC50cmFuc2xhdGlvbnMpOyAvLyByZXBsYWNlIHRoZSB0cmFuc2xhdGlvbnMgZW50aXJlbHlcblxuICAgICAgc3RhdGUudHJhbnNsYXRpb25zW3BheWxvYWQubG9jYWxlXSA9IHRyYW5zbGF0aW9uczsgLy8gbWFrZSBzdXJlIHRvIG5vdGlmeSB2dWUgb2YgY2hhbmdlcyAodGhpcyBtaWdodCBicmVhayB3aXRoIG5ldyB2dWUgdmVyc2lvbnMpXG5cbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdGF0ZS50cmFuc2xhdGlvbnMuX19vYl9fKSB7XG4gICAgICAgICAgc3RhdGUudHJhbnNsYXRpb25zLl9fb2JfXy5kZXAubm90aWZ5KCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGV4KSB7fVxuICAgIH0sXG4gICAgLy8gcmVtb3ZlIGEgbG9jYWxlIGZyb20gdGhlIHN0b3JlXG4gICAgUkVNT1ZFX0xPQ0FMRTogZnVuY3Rpb24gUkVNT1ZFX0xPQ0FMRShzdGF0ZSwgcGF5bG9hZCkge1xuICAgICAgLy8gY2hlY2sgaWYgdGhlIGdpdmVuIGxvY2FsZSBpcyBwcmVzZW50IGluIHRoZSBzdGF0ZVxuICAgICAgaWYgKHN0YXRlLnRyYW5zbGF0aW9ucy5oYXNPd25Qcm9wZXJ0eShwYXlsb2FkLmxvY2FsZSkpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgdGhlIGN1cnJlbnQgbG9jYWxlIGlzIHRoZSBnaXZlbiBsb2NhbGUgdG8gcmVtdm9lXG4gICAgICAgIGlmIChzdGF0ZS5sb2NhbGUgPT09IHBheWxvYWQubG9jYWxlKSB7XG4gICAgICAgICAgLy8gcmVzZXQgdGhlIGN1cnJlbnQgbG9jYWxlXG4gICAgICAgICAgc3RhdGUubG9jYWxlID0gbnVsbDtcbiAgICAgICAgfSAvLyBjcmVhdGUgYSBjb3B5IG9mIHRoZSB0cmFuc2xhdGlvbnMgb2JqZWN0XG5cblxuICAgICAgICB2YXIgdHJhbnNsYXRpb25Db3B5ID0gT2JqZWN0LmFzc2lnbih7fSwgc3RhdGUudHJhbnNsYXRpb25zKTsgLy8gcmVtb3ZlIHRoZSBnaXZlbiBsb2NhbGVcblxuICAgICAgICBkZWxldGUgdHJhbnNsYXRpb25Db3B5W3BheWxvYWQubG9jYWxlXTsgLy8gc2V0IHRoZSBzdGF0ZSB0byB0aGUgbmV3IG9iamVjdFxuXG4gICAgICAgIHN0YXRlLnRyYW5zbGF0aW9ucyA9IHRyYW5zbGF0aW9uQ29weTtcbiAgICAgIH1cbiAgICB9LFxuICAgIFNFVF9GQUxMQkFDS19MT0NBTEU6IGZ1bmN0aW9uIFNFVF9GQUxMQkFDS19MT0NBTEUoc3RhdGUsIHBheWxvYWQpIHtcbiAgICAgIHN0YXRlLmZhbGxiYWNrID0gcGF5bG9hZC5sb2NhbGU7XG4gICAgfVxuICB9LFxuICBhY3Rpb25zOiB7XG4gICAgLy8gc2V0IHRoZSBjdXJyZW50IGxvY2FsZVxuICAgIHNldExvY2FsZTogZnVuY3Rpb24gc2V0TG9jYWxlKGNvbnRleHQsIHBheWxvYWQpIHtcbiAgICAgIGNvbnRleHQuY29tbWl0KHtcbiAgICAgICAgdHlwZTogJ1NFVF9MT0NBTEUnLFxuICAgICAgICBsb2NhbGU6IHBheWxvYWQubG9jYWxlXG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIGFkZCBvciBleHRlbmQgYSBsb2NhbGUgd2l0aCB0cmFuc2xhdGlvbnNcbiAgICBhZGRMb2NhbGU6IGZ1bmN0aW9uIGFkZExvY2FsZShjb250ZXh0LCBwYXlsb2FkKSB7XG4gICAgICBjb250ZXh0LmNvbW1pdCh7XG4gICAgICAgIHR5cGU6ICdBRERfTE9DQUxFJyxcbiAgICAgICAgbG9jYWxlOiBwYXlsb2FkLmxvY2FsZSxcbiAgICAgICAgdHJhbnNsYXRpb25zOiBwYXlsb2FkLnRyYW5zbGF0aW9uc1xuICAgICAgfSk7XG4gICAgfSxcbiAgICAvLyByZXBsYWNlIGxvY2FsZSBpbmZvcm1hdGlvblxuICAgIHJlcGxhY2VMb2NhbGU6IGZ1bmN0aW9uIHJlcGxhY2VMb2NhbGUoY29udGV4dCwgcGF5bG9hZCkge1xuICAgICAgY29udGV4dC5jb21taXQoe1xuICAgICAgICB0eXBlOiAnUkVQTEFDRV9MT0NBTEUnLFxuICAgICAgICBsb2NhbGU6IHBheWxvYWQubG9jYWxlLFxuICAgICAgICB0cmFuc2xhdGlvbnM6IHBheWxvYWQudHJhbnNsYXRpb25zXG4gICAgICB9KTtcbiAgICB9LFxuICAgIC8vIHJlbW92ZSB0aGUgZ2l2ZW4gbG9jYWxlIHRyYW5zbGF0aW9uc1xuICAgIHJlbW92ZUxvY2FsZTogZnVuY3Rpb24gcmVtb3ZlTG9jYWxlKGNvbnRleHQsIHBheWxvYWQpIHtcbiAgICAgIGNvbnRleHQuY29tbWl0KHtcbiAgICAgICAgdHlwZTogJ1JFTU9WRV9MT0NBTEUnLFxuICAgICAgICBsb2NhbGU6IHBheWxvYWQubG9jYWxlLFxuICAgICAgICB0cmFuc2xhdGlvbnM6IHBheWxvYWQudHJhbnNsYXRpb25zXG4gICAgICB9KTtcbiAgICB9LFxuICAgIHNldEZhbGxiYWNrTG9jYWxlOiBmdW5jdGlvbiBzZXRGYWxsYmFja0xvY2FsZShjb250ZXh0LCBwYXlsb2FkKSB7XG4gICAgICBjb250ZXh0LmNvbW1pdCh7XG4gICAgICAgIHR5cGU6ICdTRVRfRkFMTEJBQ0tfTE9DQUxFJyxcbiAgICAgICAgbG9jYWxlOiBwYXlsb2FkLmxvY2FsZVxuICAgICAgfSk7XG4gICAgfVxuICB9XG59OyAvLyBmbGF0dGVuVHJhbnNsYXRpb25zIHdpbGwgY29udmVydCBvYmplY3QgdHJlZXMgZm9yIHRyYW5zbGF0aW9ucyBpbnRvIGFcbi8vIHNpbmdsZS1kZXB0aCBvYmplY3QgdHJlZVxuXG52YXIgZmxhdHRlblRyYW5zbGF0aW9ucyA9IGZ1bmN0aW9uIGZsYXR0ZW5UcmFuc2xhdGlvbnModHJhbnNsYXRpb25zKSB7XG4gIHZhciB0b1JldHVybiA9IHt9O1xuXG4gIGZvciAodmFyIGkgaW4gdHJhbnNsYXRpb25zKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIHByb3BlcnR5IGlzIHByZXNlbnRcbiAgICBpZiAoIXRyYW5zbGF0aW9ucy5oYXNPd25Qcm9wZXJ0eShpKSkge1xuICAgICAgY29udGludWU7XG4gICAgfSAvLyBnZXQgdGhlIHR5cGUgb2YgdGhlIHByb3BlcnR5XG5cblxuICAgIHZhciBvYmpUeXBlID0gX3R5cGVvZih0cmFuc2xhdGlvbnNbaV0pOyAvLyBhbGxvdyB1bmZsYXR0ZW5lZCBhcnJheSBvZiBzdHJpbmdzXG5cblxuICAgIGlmIChpc0FycmF5KHRyYW5zbGF0aW9uc1tpXSkpIHtcbiAgICAgIHZhciBjb3VudCA9IHRyYW5zbGF0aW9uc1tpXS5sZW5ndGg7XG5cbiAgICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBjb3VudDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgaXRlbVR5cGUgPSBfdHlwZW9mKHRyYW5zbGF0aW9uc1tpXVtpbmRleF0pO1xuXG4gICAgICAgIGlmIChpdGVtVHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ2kxOG46JywgJ2N1cnJlbnRseSBvbmx5IGFycmF5cyBvZiBzdHJpbmdzIGFyZSBmdWxseSBzdXBwb3J0ZWQnLCB0cmFuc2xhdGlvbnNbaV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHRvUmV0dXJuW2ldID0gdHJhbnNsYXRpb25zW2ldO1xuICAgIH0gZWxzZSBpZiAob2JqVHlwZSA9PSAnb2JqZWN0JyAmJiBvYmpUeXBlICE9PSBudWxsKSB7XG4gICAgICB2YXIgZmxhdE9iamVjdCA9IGZsYXR0ZW5UcmFuc2xhdGlvbnModHJhbnNsYXRpb25zW2ldKTtcblxuICAgICAgZm9yICh2YXIgeCBpbiBmbGF0T2JqZWN0KSB7XG4gICAgICAgIGlmICghZmxhdE9iamVjdC5oYXNPd25Qcm9wZXJ0eSh4KSkgY29udGludWU7XG4gICAgICAgIHRvUmV0dXJuW2kgKyAnLicgKyB4XSA9IGZsYXRPYmplY3RbeF07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRvUmV0dXJuW2ldID0gdHJhbnNsYXRpb25zW2ldO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiB0b1JldHVybjtcbn07IC8vIGNoZWNrIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gYXJyYXlcblxuXG5mdW5jdGlvbiBpc0FycmF5KG9iaikge1xuICByZXR1cm4gISFvYmogJiYgQXJyYXkgPT09IG9iai5jb25zdHJ1Y3Rvcjtcbn1cblxudmFyIHBsdXJhbHMgPSB7XG4gIGdldFRyYW5zbGF0aW9uSW5kZXg6IGZ1bmN0aW9uIGdldFRyYW5zbGF0aW9uSW5kZXgobGFuZ3VhZ2VDb2RlLCBuKSB7XG4gICAgc3dpdGNoIChsYW5ndWFnZUNvZGUpIHtcbiAgICAgIGNhc2UgJ2F5JzogLy8gQXltYXLDoVxuXG4gICAgICBjYXNlICdibyc6IC8vIFRpYmV0YW5cblxuICAgICAgY2FzZSAnY2dnJzogLy8gQ2hpZ2FcblxuICAgICAgY2FzZSAnZHonOiAvLyBEem9uZ2toYVxuXG4gICAgICBjYXNlICdmYSc6IC8vIFBlcnNpYW5cblxuICAgICAgY2FzZSAnaWQnOiAvLyBJbmRvbmVzaWFuXG5cbiAgICAgIGNhc2UgJ2phJzogLy8gSmFwYW5lc2VcblxuICAgICAgY2FzZSAnamJvJzogLy8gTG9qYmFuXG5cbiAgICAgIGNhc2UgJ2thJzogLy8gR2VvcmdpYW5cblxuICAgICAgY2FzZSAna2snOiAvLyBLYXpha2hcblxuICAgICAgY2FzZSAna20nOiAvLyBLaG1lclxuXG4gICAgICBjYXNlICdrbyc6IC8vIEtvcmVhblxuXG4gICAgICBjYXNlICdreSc6IC8vIEt5cmd5elxuXG4gICAgICBjYXNlICdsbyc6IC8vIExhb1xuXG4gICAgICBjYXNlICdtcyc6IC8vIE1hbGF5XG5cbiAgICAgIGNhc2UgJ215JzogLy8gQnVybWVzZVxuXG4gICAgICBjYXNlICdzYWgnOiAvLyBZYWt1dFxuXG4gICAgICBjYXNlICdzdSc6IC8vIFN1bmRhbmVzZVxuXG4gICAgICBjYXNlICd0aCc6IC8vIFRoYWlcblxuICAgICAgY2FzZSAndHQnOiAvLyBUYXRhclxuXG4gICAgICBjYXNlICd1Zyc6IC8vIFV5Z2h1clxuXG4gICAgICBjYXNlICd2aSc6IC8vIFZpZXRuYW1lc2VcblxuICAgICAgY2FzZSAnd28nOiAvLyBXb2xvZlxuXG4gICAgICBjYXNlICd6aCc6XG4gICAgICAgIC8vIENoaW5lc2VcbiAgICAgICAgLy8gMSBmb3JtXG4gICAgICAgIHJldHVybiAwO1xuXG4gICAgICBjYXNlICdpcyc6XG4gICAgICAgIC8vIEljZWxhbmRpY1xuICAgICAgICAvLyAyIGZvcm1zXG4gICAgICAgIHJldHVybiBuICUgMTAgIT09IDEgfHwgbiAlIDEwMCA9PT0gMTEgPyAxIDogMDtcblxuICAgICAgY2FzZSAnanYnOlxuICAgICAgICAvLyBKYXZhbmVzZVxuICAgICAgICAvLyAyIGZvcm1zXG4gICAgICAgIHJldHVybiBuICE9PSAwID8gMSA6IDA7XG5cbiAgICAgIGNhc2UgJ21rJzpcbiAgICAgICAgLy8gTWFjZWRvbmlhblxuICAgICAgICAvLyAyIGZvcm1zXG4gICAgICAgIHJldHVybiBuID09PSAxIHx8IG4gJSAxMCA9PT0gMSA/IDAgOiAxO1xuXG4gICAgICBjYXNlICdhY2gnOiAvLyBBY2hvbGlcblxuICAgICAgY2FzZSAnYWsnOiAvLyBBa2FuXG5cbiAgICAgIGNhc2UgJ2FtJzogLy8gQW1oYXJpY1xuXG4gICAgICBjYXNlICdhcm4nOiAvLyBNYXB1ZHVuZ3VuXG5cbiAgICAgIGNhc2UgJ2JyJzogLy8gQnJldG9uXG5cbiAgICAgIGNhc2UgJ2ZpbCc6IC8vIEZpbGlwaW5vXG5cbiAgICAgIGNhc2UgJ2ZyJzogLy8gRnJlbmNoXG5cbiAgICAgIGNhc2UgJ2d1bic6IC8vIEd1blxuXG4gICAgICBjYXNlICdsbic6IC8vIExpbmdhbGFcblxuICAgICAgY2FzZSAnbWZlJzogLy8gTWF1cml0aWFuIENyZW9sZVxuXG4gICAgICBjYXNlICdtZyc6IC8vIE1hbGFnYXN5XG5cbiAgICAgIGNhc2UgJ21pJzogLy8gTWFvcmlcblxuICAgICAgY2FzZSAnb2MnOiAvLyBPY2NpdGFuXG5cbiAgICAgIGNhc2UgJ3B0X0JSJzogLy8gQnJhemlsaWFuIFBvcnR1Z3Vlc2VcblxuICAgICAgY2FzZSAndGcnOiAvLyBUYWppa1xuXG4gICAgICBjYXNlICd0aSc6IC8vIFRpZ3JpbnlhXG5cbiAgICAgIGNhc2UgJ3RyJzogLy8gVHVya2lzaFxuXG4gICAgICBjYXNlICd1eic6IC8vIFV6YmVrXG5cbiAgICAgIGNhc2UgJ3dhJzogLy8gV2FsbG9vblxuXG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4gICAgICAvKiBEaXNhYmxlIFwiRHVwbGljYXRlIGNhc2UgbGFiZWxcIiBiZWNhdXNlIHRoZXJlIGFyZSAyIGZvcm1zIG9mIENoaW5lc2UgcGx1cmFscyAqL1xuXG4gICAgICBjYXNlICd6aCc6XG4gICAgICAgIC8vIENoaW5lc2VcblxuICAgICAgICAvKiBlc2xpbnQtZW5hYmxlICovXG4gICAgICAgIC8vIDIgZm9ybXNcbiAgICAgICAgcmV0dXJuIG4gPiAxID8gMSA6IDA7XG5cbiAgICAgIGNhc2UgJ2x2JzpcbiAgICAgICAgLy8gTGF0dmlhblxuICAgICAgICAvLyAzIGZvcm1zXG4gICAgICAgIHJldHVybiBuICUgMTAgPT09IDEgJiYgbiAlIDEwMCAhPT0gMTEgPyAwIDogbiAhPT0gMCA/IDEgOiAyO1xuXG4gICAgICBjYXNlICdsdCc6XG4gICAgICAgIC8vIExpdGh1YW5pYW5cbiAgICAgICAgLy8gMyBmb3Jtc1xuICAgICAgICByZXR1cm4gbiAlIDEwID09PSAxICYmIG4gJSAxMDAgIT09IDExID8gMCA6IG4gJSAxMCA+PSAyICYmIChuICUgMTAwIDwgMTAgfHwgbiAlIDEwMCA+PSAyMCkgPyAxIDogMjtcblxuICAgICAgY2FzZSAnYmUnOiAvLyBCZWxhcnVzaWFuXG5cbiAgICAgIGNhc2UgJ2JzJzogLy8gQm9zbmlhblxuXG4gICAgICBjYXNlICdocic6IC8vIENyb2F0aWFuXG5cbiAgICAgIGNhc2UgJ3J1JzogLy8gUnVzc2lhblxuXG4gICAgICBjYXNlICdzcic6IC8vIFNlcmJpYW5cblxuICAgICAgY2FzZSAndWsnOlxuICAgICAgICAvLyBVa3JhaW5pYW5cbiAgICAgICAgLy8gMyBmb3Jtc1xuICAgICAgICByZXR1cm4gbiAlIDEwID09PSAxICYmIG4gJSAxMDAgIT09IDExID8gMCA6IG4gJSAxMCA+PSAyICYmIG4gJSAxMCA8PSA0ICYmIChuICUgMTAwIDwgMTAgfHwgbiAlIDEwMCA+PSAyMCkgPyAxIDogMjtcblxuICAgICAgY2FzZSAnbW5rJzpcbiAgICAgICAgLy8gTWFuZGlua2FcbiAgICAgICAgLy8gMyBmb3Jtc1xuICAgICAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiBuID09PSAxID8gMSA6IDI7XG5cbiAgICAgIGNhc2UgJ3JvJzpcbiAgICAgICAgLy8gUm9tYW5pYW5cbiAgICAgICAgLy8gMyBmb3Jtc1xuICAgICAgICByZXR1cm4gbiA9PT0gMSA/IDAgOiBuID09PSAwIHx8IG4gJSAxMDAgPiAwICYmIG4gJSAxMDAgPCAyMCA/IDEgOiAyO1xuXG4gICAgICBjYXNlICdwbCc6XG4gICAgICAgIC8vIFBvbGlzaFxuICAgICAgICAvLyAzIGZvcm1zXG4gICAgICAgIHJldHVybiBuID09PSAxID8gMCA6IG4gJSAxMCA+PSAyICYmIG4gJSAxMCA8PSA0ICYmIChuICUgMTAwIDwgMTAgfHwgbiAlIDEwMCA+PSAyMCkgPyAxIDogMjtcblxuICAgICAgY2FzZSAnY3MnOiAvLyBDemVjaFxuXG4gICAgICBjYXNlICdzayc6XG4gICAgICAgIC8vIFNsb3Zha1xuICAgICAgICAvLyAzIGZvcm1zXG4gICAgICAgIHJldHVybiBuID09PSAxID8gMCA6IG4gPj0gMiAmJiBuIDw9IDQgPyAxIDogMjtcblxuICAgICAgY2FzZSAnY3NiJzpcbiAgICAgICAgLy8gS2FzaHViaWFuXG4gICAgICAgIC8vIDMgZm9ybXNcbiAgICAgICAgcmV0dXJuIG4gPT09IDEgPyAwIDogbiAlIDEwID49IDIgJiYgbiAlIDEwIDw9IDQgJiYgKG4gJSAxMDAgPCAxMCB8fCBuICUgMTAwID49IDIwKSA/IDEgOiAyO1xuXG4gICAgICBjYXNlICdzbCc6XG4gICAgICAgIC8vIFNsb3ZlbmlhblxuICAgICAgICAvLyA0IGZvcm1zXG4gICAgICAgIHJldHVybiBuICUgMTAwID09PSAxID8gMCA6IG4gJSAxMDAgPT09IDIgPyAxIDogbiAlIDEwMCA9PT0gMyB8fCBuICUgMTAwID09PSA0ID8gMiA6IDM7XG5cbiAgICAgIGNhc2UgJ210JzpcbiAgICAgICAgLy8gTWFsdGVzZVxuICAgICAgICAvLyA0IGZvcm1zXG4gICAgICAgIHJldHVybiBuID09PSAxID8gMCA6IG4gPT09IDAgfHwgbiAlIDEwMCA+IDEgJiYgbiAlIDEwMCA8IDExID8gMSA6IG4gJSAxMDAgPiAxMCAmJiBuICUgMTAwIDwgMjAgPyAyIDogMztcblxuICAgICAgY2FzZSAnZ2QnOlxuICAgICAgICAvLyBTY290dGlzaCBHYWVsaWNcbiAgICAgICAgLy8gNCBmb3Jtc1xuICAgICAgICByZXR1cm4gbiA9PT0gMSB8fCBuID09PSAxMSA/IDAgOiBuID09PSAyIHx8IG4gPT09IDEyID8gMSA6IG4gPiAyICYmIG4gPCAyMCA/IDIgOiAzO1xuXG4gICAgICBjYXNlICdjeSc6XG4gICAgICAgIC8vIFdlbHNoXG4gICAgICAgIC8vIDQgZm9ybXNcbiAgICAgICAgcmV0dXJuIG4gPT09IDEgPyAwIDogbiA9PT0gMiA/IDEgOiBuICE9PSA4ICYmIG4gIT09IDExID8gMiA6IDM7XG5cbiAgICAgIGNhc2UgJ2t3JzpcbiAgICAgICAgLy8gQ29ybmlzaFxuICAgICAgICAvLyA0IGZvcm1zXG4gICAgICAgIHJldHVybiBuID09PSAxID8gMCA6IG4gPT09IDIgPyAxIDogbiA9PT0gMyA/IDIgOiAzO1xuXG4gICAgICBjYXNlICdnYSc6XG4gICAgICAgIC8vIElyaXNoXG4gICAgICAgIC8vIDUgZm9ybXNcbiAgICAgICAgcmV0dXJuIG4gPT09IDEgPyAwIDogbiA9PT0gMiA/IDEgOiBuID4gMiAmJiBuIDwgNyA/IDIgOiBuID4gNiAmJiBuIDwgMTEgPyAzIDogNDtcblxuICAgICAgY2FzZSAnYXInOlxuICAgICAgICAvLyBBcmFiaWNcbiAgICAgICAgLy8gNiBmb3Jtc1xuICAgICAgICByZXR1cm4gbiA9PT0gMCA/IDAgOiBuID09PSAxID8gMSA6IG4gPT09IDIgPyAyIDogbiAlIDEwMCA+PSAzICYmIG4gJSAxMDAgPD0gMTAgPyAzIDogbiAlIDEwMCA+PSAxMSA/IDQgOiA1O1xuXG4gICAgICBkZWZhdWx0OlxuICAgICAgICAvLyBFdmVyeXRoaW5nIGVsc2VcbiAgICAgICAgcmV0dXJuIG4gIT09IDEgPyAxIDogMDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciBWdWV4STE4blBsdWdpbiA9IHt9OyAvLyBpbnRlcm5hdGlvbmFsaXphdGlvbiBwbHVnaW4gZm9yIHZ1ZSBqcyB1c2luZyB2dWV4XG5cblZ1ZXhJMThuUGx1Z2luLmluc3RhbGwgPSBmdW5jdGlvbiBpbnN0YWxsKFZ1ZSwgc3RvcmUsIGNvbmZpZykge1xuICAvLyBUT0RPOiByZW1vdmUgdGhpcyBibG9jayBmb3IgbmV4dCBtYWpvciB1cGRhdGUgKEFQSSBicmVhaylcbiAgaWYgKHR5cGVvZiBhcmd1bWVudHNbMl0gPT09ICdzdHJpbmcnIHx8IHR5cGVvZiBhcmd1bWVudHNbM10gPT09ICdzdHJpbmcnKSB7XG4gICAgY29uc29sZS53YXJuKCdpMThuOiBSZWdpc3RlcmluZyB0aGUgcGx1Z2luIHZ1ZXgtaTE4biB3aXRoIGEgc3RyaW5nIGZvciBgbW9kdWxlTmFtZWAgb3IgYGlkZW50aWZpZXJzYCBpcyBkZXByZWNhdGVkLiBVc2UgYSBjb25maWd1cmF0aW9uIG9iamVjdCBpbnN0ZWFkLicsICdodHRwczovL2dpdGh1Yi5jb20vZGtmYmFzZWwvdnVleC1pMThuI3NldHVwJyk7XG4gICAgY29uZmlnID0ge1xuICAgICAgbW9kdWxlTmFtZTogYXJndW1lbnRzWzJdLFxuICAgICAgaWRlbnRpZmllcnM6IGFyZ3VtZW50c1szXVxuICAgIH07XG4gIH0gLy8gbWVyZ2UgZGVmYXVsdCBvcHRpb25zIHdpdGggdXNlciBzdXBwbGllZCBvcHRpb25zXG5cblxuICBjb25maWcgPSBPYmplY3QuYXNzaWduKHtcbiAgICB3YXJuaW5nczogdHJ1ZSxcbiAgICBtb2R1bGVOYW1lOiAnaTE4bicsXG4gICAgaWRlbnRpZmllcnM6IFsneycsICd9J10sXG4gICAgcHJlc2VydmVTdGF0ZTogZmFsc2UsXG4gICAgdHJhbnNsYXRlRmlsdGVyTmFtZTogJ3RyYW5zbGF0ZScsXG4gICAgdHJhbnNsYXRlSW5GaWx0ZXJOYW1lOiAndHJhbnNsYXRlSW4nLFxuICAgIG9uVHJhbnNsYXRpb25Ob3RGb3VuZDogZnVuY3Rpb24gb25UcmFuc2xhdGlvbk5vdEZvdW5kKCkge31cbiAgfSwgY29uZmlnKTsgLy8gZGVmaW5lIG1vZHVsZSBuYW1lIGFuZCBpZGVudGlmaWVycyBhcyBjb25zdGFudHMgdG8gcHJldmVudCBhbnkgY2hhbmdlc1xuXG4gIHZhciBtb2R1bGVOYW1lID0gY29uZmlnLm1vZHVsZU5hbWU7XG4gIHZhciBpZGVudGlmaWVycyA9IGNvbmZpZy5pZGVudGlmaWVycztcbiAgdmFyIHRyYW5zbGF0ZUZpbHRlck5hbWUgPSBjb25maWcudHJhbnNsYXRlRmlsdGVyTmFtZTtcbiAgdmFyIHRyYW5zbGF0ZUluRmlsdGVyTmFtZSA9IGNvbmZpZy50cmFuc2xhdGVJbkZpbHRlck5hbWU7IC8vIGluaXRpYWxpemUgdGhlIG9uVHJhbnNsYXRpb25Ob3RGb3VuZCBmdW5jdGlvbiBhbmQgbWFrZSBzdXJlIGl0IGlzIGFjdHVhbGx5XG4gIC8vIGEgZnVuY3Rpb25cblxuICB2YXIgb25UcmFuc2xhdGlvbk5vdEZvdW5kID0gY29uZmlnLm9uVHJhbnNsYXRpb25Ob3RGb3VuZDtcblxuICBpZiAodHlwZW9mIG9uVHJhbnNsYXRpb25Ob3RGb3VuZCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgIGNvbnNvbGUuZXJyb3IoJ2kxOG46IGkxOG4gY29uZmlnIG9wdGlvbiBvblRyYW5zbGF0aW9uTm90Rm91bmQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICBvblRyYW5zbGF0aW9uTm90Rm91bmQgPSBmdW5jdGlvbiBvblRyYW5zbGF0aW9uTm90Rm91bmQoKSB7fTtcbiAgfSAvLyByZWdpc3RlciB0aGUgaTE4biBtb2R1bGUgaW4gdGhlIHZ1ZXggc3RvcmVcbiAgLy8gcHJlc2VydmVTdGF0ZSBjYW4gYmUgdXNlZCB2aWEgY29uZmlndXJhdGlvbiBpZiBzZXJ2ZXIgc2lkZSByZW5kZXJpbmcgaXMgdXNlZFxuXG5cbiAgc3RvcmUucmVnaXN0ZXJNb2R1bGUobW9kdWxlTmFtZSwgaTE4blZ1ZXhNb2R1bGUsIHtcbiAgICBwcmVzZXJ2ZVN0YXRlOiBjb25maWcucHJlc2VydmVTdGF0ZVxuICB9KTsgLy8gY2hlY2sgaWYgdGhlIHBsdWdpbiB3YXMgY29ycmVjdGx5IGluaXRpYWxpemVkXG5cbiAgaWYgKHN0b3JlLnN0YXRlLmhhc093blByb3BlcnR5KG1vZHVsZU5hbWUpID09PSBmYWxzZSkge1xuICAgIGNvbnNvbGUuZXJyb3IoJ2kxOG46IGkxOG4gdnVleCBtb2R1bGUgaXMgbm90IGNvcnJlY3RseSBpbml0aWFsaXplZC4gUGxlYXNlIGNoZWNrIHRoZSBtb2R1bGUgbmFtZTonLCBtb2R1bGVOYW1lKTsgLy8gYWx3YXlzIHJldHVybiB0aGUga2V5IGlmIG1vZHVsZSBpcyBub3QgaW5pdGlhbGl6ZWQgY29ycmVjdGx5XG5cbiAgICBWdWUucHJvdG90eXBlLiRpMThuID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgcmV0dXJuIGtleTtcbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kZ2V0TGFuZ3VhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuXG4gICAgVnVlLnByb3RvdHlwZS4kc2V0TGFuZ3VhZ2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCdpMThuOiBpMThuIHZ1ZXggbW9kdWxlIGlzIG5vdCBjb3JyZWN0bHkgaW5pdGlhbGl6ZWQnKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIHJlbmRlciA9IHJlbmRlckZuKGlkZW50aWZpZXJzLCBjb25maWcud2FybmluZ3MpOyAvLyBnZXQgbG9jYWxpemVkIHN0cmluZyBmcm9tIHN0b3JlLiBub3RlIHRoYXQgd2UgcGFzcyB0aGUgYXJndW1lbnRzIHBhc3NlZFxuICAvLyB0byB0aGUgZnVuY3Rpb24gZGlyZWN0bHkgdG8gdGhlIHRyYW5zbGF0ZUluTGFuZ3VhZ2UgZnVuY3Rpb25cblxuICB2YXIgdHJhbnNsYXRlID0gZnVuY3Rpb24gJHQoKSB7XG4gICAgLy8gZ2V0IHRoZSBjdXJyZW50IGxhbmd1YWdlIGZyb20gdGhlIHN0b3JlXG4gICAgdmFyIGxvY2FsZSA9IHN0b3JlLnN0YXRlW21vZHVsZU5hbWVdLmxvY2FsZTtcbiAgICByZXR1cm4gdHJhbnNsYXRlSW5MYW5ndWFnZS5hcHBseSh2b2lkIDAsIFtsb2NhbGVdLmNvbmNhdChBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpKSk7XG4gIH07IC8vIGdldCBsb2NhbGl6ZWQgc3RyaW5nIGZyb20gc3RvcmUgaW4gYSBnaXZlbiBsYW5ndWFnZSBpZiBhdmFpbGFibGUuXG4gIC8vIHRoZXJlIGFyZSB0d28gcG9zc2libGUgc2lnbmF0dXJlcyBmb3IgdGhlIGZ1bmN0aW9uLlxuICAvLyB3ZSB3aWxsIGNoZWNrIHRoZSBhcmd1bWVudHMgdG8gbWFrZSB1cCB0aGUgb3B0aW9ucyBwYXNzZWQuXG4gIC8vIDE6IGxvY2FsZSwga2V5LCBvcHRpb25zLCBwbHVyYWxpemF0aW9uXG4gIC8vIDI6IGxvY2FsZSwga2V5LCBkZWZhdWx0VmFsdWUsIG9wdGlvbnMsIHBsdXJhbGl6YXRpb25cblxuXG4gIHZhciB0cmFuc2xhdGVJbkxhbmd1YWdlID0gZnVuY3Rpb24gdHJhbnNsYXRlSW5MYW5ndWFnZShsb2NhbGUpIHtcbiAgICAvLyByZWFkIHRoZSBmdW5jdGlvbiBhcmd1bWVudHNcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50czsgLy8gaW5pdGlhbGl6ZSBvcHRpb25zXG5cbiAgICB2YXIga2V5ID0gJyc7XG4gICAgdmFyIGRlZmF1bHRWYWx1ZSA9ICcnO1xuICAgIHZhciBvcHRpb25zID0ge307XG4gICAgdmFyIHBsdXJhbGl6YXRpb24gPSBudWxsO1xuICAgIHZhciBjb3VudCA9IGFyZ3MubGVuZ3RoOyAvLyBjaGVjayBpZiBhIGRlZmF1bHQgdmFsdWUgd2FzIHNwZWNpZmllZCBhbmQgZmlsbCBvcHRpb25zIGFjY29yZGluZ2x5XG5cbiAgICBpZiAoY291bnQgPj0gMyAmJiB0eXBlb2YgYXJnc1syXSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGtleSA9IGFyZ3NbMV07XG4gICAgICBkZWZhdWx0VmFsdWUgPSBhcmdzWzJdO1xuXG4gICAgICBpZiAoY291bnQgPiAzKSB7XG4gICAgICAgIG9wdGlvbnMgPSBhcmdzWzNdO1xuICAgICAgfVxuXG4gICAgICBpZiAoY291bnQgPiA0KSB7XG4gICAgICAgIHBsdXJhbGl6YXRpb24gPSBhcmdzWzRdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBhcmdzWzFdOyAvLyBkZWZhdWx0IHZhbHVlIHdhcyBub3Qgc3BlY2lmaWVkIGFuZCBpcyB0aGVyZWZvcmUgdGhlIHNhbWUgYXMgdGhlIGtleVxuXG4gICAgICBkZWZhdWx0VmFsdWUgPSBrZXk7XG5cbiAgICAgIGlmIChjb3VudCA+IDIpIHtcbiAgICAgICAgb3B0aW9ucyA9IGFyZ3NbMl07XG4gICAgICB9XG5cbiAgICAgIGlmIChjb3VudCA+IDMpIHtcbiAgICAgICAgcGx1cmFsaXphdGlvbiA9IGFyZ3NbM107XG4gICAgICB9XG4gICAgfSAvLyByZXR1cm4gdGhlIGRlZmF1bHQgdmFsdWUgaWYgdGhlIGxvY2FsZSBpcyBub3Qgc2V0IChjb3VsZCBoYXBwZW4gb24gaW5pdGlhbGl6YXRpb24pXG5cblxuICAgIGlmICghbG9jYWxlKSB7XG4gICAgICBpZiAoY29uZmlnLndhcm5pbmdzKSBjb25zb2xlLndhcm4oJ2kxOG46IGkxOG4gbG9jYWxlIGlzIG5vdCBzZXQgd2hlbiB0cnlpbmcgdG8gYWNjZXNzIHRyYW5zbGF0aW9uczonLCBrZXkpO1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9IC8vIGdldCB0aGUgdHJhbnNsYXRpb25zIGZyb20gdGhlIHN0b3JlXG5cblxuICAgIHZhciB0cmFuc2xhdGlvbnMgPSBzdG9yZS5zdGF0ZVttb2R1bGVOYW1lXS50cmFuc2xhdGlvbnM7IC8vIGdldCB0aGUgbGFzdCByZXNvcnQgZmFsbGJhY2sgZnJvbSB0aGUgc3RvcmVcblxuICAgIHZhciBmYWxsYmFjayA9IHN0b3JlLnN0YXRlW21vZHVsZU5hbWVdLmZhbGxiYWNrOyAvLyBzcGxpdCBsb2NhbGUgYnkgLSB0byBzdXBwb3J0IHBhcnRpYWwgZmFsbGJhY2sgZm9yIHJlZ2lvbmFsIGxvY2FsZXNcbiAgICAvLyBsaWtlIGRlLUNILCBlbi1VS1xuXG4gICAgdmFyIGxvY2FsZVJlZ2lvbmFsID0gbG9jYWxlLnNwbGl0KCctJyk7IC8vIGZsYWcgZm9yIHRyYW5zbGF0aW9uIHRvIGV4aXN0IG9yIG5vdFxuXG4gICAgdmFyIHRyYW5zbGF0aW9uRXhpc3RzID0gdHJ1ZTsgLy8gY2hlY2sgaWYgdGhlIGxhbmd1YWdlIGV4aXN0cyBpbiB0aGUgc3RvcmUuIHJldHVybiB0aGUga2V5IGlmIG5vdFxuXG4gICAgaWYgKHRyYW5zbGF0aW9ucy5oYXNPd25Qcm9wZXJ0eShsb2NhbGUpID09PSBmYWxzZSkge1xuICAgICAgdHJhbnNsYXRpb25FeGlzdHMgPSBmYWxzZTsgLy8gY2hlY2sgaWYgdGhlIGtleSBleGlzdHMgaW4gdGhlIHN0b3JlLiByZXR1cm4gdGhlIGtleSBpZiBub3RcbiAgICB9IGVsc2UgaWYgKHRyYW5zbGF0aW9uc1tsb2NhbGVdLmhhc093blByb3BlcnR5KGtleSkgPT09IGZhbHNlKSB7XG4gICAgICB0cmFuc2xhdGlvbkV4aXN0cyA9IGZhbHNlO1xuICAgIH0gLy8gcmV0dXJuIHRoZSB2YWx1ZSBmcm9tIHRoZSBzdG9yZVxuXG5cbiAgICBpZiAodHJhbnNsYXRpb25FeGlzdHMgPT09IHRydWUpIHtcbiAgICAgIHJldHVybiByZW5kZXIobG9jYWxlLCB0cmFuc2xhdGlvbnNbbG9jYWxlXVtrZXldLCBvcHRpb25zLCBwbHVyYWxpemF0aW9uKTtcbiAgICB9IC8vIGNoZWNrIGlmIGEgcmVnaW9uYWwgbG9jYWxlIHRyYW5zbGF0aW9uIHdvdWxkIGJlIGF2YWlsYWJsZSBmb3IgdGhlIGtleVxuICAgIC8vIGkuZS4gZGUgZm9yIGRlLUNIXG5cblxuICAgIGlmIChsb2NhbGVSZWdpb25hbC5sZW5ndGggPiAxICYmIHRyYW5zbGF0aW9ucy5oYXNPd25Qcm9wZXJ0eShsb2NhbGVSZWdpb25hbFswXSkgPT09IHRydWUgJiYgdHJhbnNsYXRpb25zW2xvY2FsZVJlZ2lvbmFsWzBdXS5oYXNPd25Qcm9wZXJ0eShrZXkpID09PSB0cnVlKSB7XG4gICAgICByZXR1cm4gcmVuZGVyKGxvY2FsZVJlZ2lvbmFsWzBdLCB0cmFuc2xhdGlvbnNbbG9jYWxlUmVnaW9uYWxbMF1dW2tleV0sIG9wdGlvbnMsIHBsdXJhbGl6YXRpb24pO1xuICAgIH0gLy8gaW52b2tlIGEgbWV0aG9kIGlmIGEgdHJhbnNsYXRpb24gaXMgbm90IGZvdW5kXG5cblxuICAgIHZhciBhc3luY1RyYW5zbGF0aW9uID0gb25UcmFuc2xhdGlvbk5vdEZvdW5kKGxvY2FsZSwga2V5LCBkZWZhdWx0VmFsdWUpOyAvLyByZXNvbHZlIGFzeW5jIHRyYW5zbGF0aW9ucyBieSB1cGRhdGluZyB0aGUgc3RvcmVcblxuICAgIGlmIChhc3luY1RyYW5zbGF0aW9uKSB7XG4gICAgICBQcm9taXNlLnJlc29sdmUoYXN5bmNUcmFuc2xhdGlvbikudGhlbihmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGFkZGl0aW9uYWxUcmFuc2xhdGlvbnMgPSB7fTtcbiAgICAgICAgYWRkaXRpb25hbFRyYW5zbGF0aW9uc1trZXldID0gdmFsdWU7XG4gICAgICAgIGFkZExvY2FsZShsb2NhbGUsIGFkZGl0aW9uYWxUcmFuc2xhdGlvbnMpO1xuICAgICAgfSk7XG4gICAgfSAvLyBjaGVjayBpZiBhIHZhaWxkIGZhbGxiYWNrIGV4aXN0cyBpbiB0aGUgc3RvcmUuXG4gICAgLy8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlIGlmIG5vdFxuXG5cbiAgICBpZiAodHJhbnNsYXRpb25zLmhhc093blByb3BlcnR5KGZhbGxiYWNrKSA9PT0gZmFsc2UpIHtcbiAgICAgIHJldHVybiByZW5kZXIobG9jYWxlLCBkZWZhdWx0VmFsdWUsIG9wdGlvbnMsIHBsdXJhbGl6YXRpb24pO1xuICAgIH0gLy8gY2hlY2sgaWYgdGhlIGtleSBleGlzdHMgaW4gdGhlIGZhbGxiYWNrIGxvY2FsZSBpbiB0aGUgc3RvcmUuXG4gICAgLy8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlIGlmIG5vdFxuXG5cbiAgICBpZiAodHJhbnNsYXRpb25zW2ZhbGxiYWNrXS5oYXNPd25Qcm9wZXJ0eShrZXkpID09PSBmYWxzZSkge1xuICAgICAgcmV0dXJuIHJlbmRlcihmYWxsYmFjaywgZGVmYXVsdFZhbHVlLCBvcHRpb25zLCBwbHVyYWxpemF0aW9uKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVuZGVyKGxvY2FsZSwgdHJhbnNsYXRpb25zW2ZhbGxiYWNrXVtrZXldLCBvcHRpb25zLCBwbHVyYWxpemF0aW9uKTtcbiAgfTsgLy8gYWRkIGEgZmlsdGVyIGZ1bmN0aW9uIHRvIHRyYW5zbGF0ZSBpbiBhIGdpdmVuIGxvY2FsZSAoaS5lLiB7eyAnc29tZXRoaW5nJyB8IHRyYW5zbGF0ZUluKCdlbicpIH19KVxuXG5cbiAgdmFyIHRyYW5zbGF0ZUluTGFuZ3VhZ2VGaWx0ZXIgPSBmdW5jdGlvbiB0cmFuc2xhdGVJbkxhbmd1YWdlRmlsdGVyKGtleSwgbG9jYWxlKSB7XG4gICAgZm9yICh2YXIgX2xlbiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbiA+IDIgPyBfbGVuIC0gMiA6IDApLCBfa2V5ID0gMjsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMl0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRyYW5zbGF0ZUluTGFuZ3VhZ2UuYXBwbHkodm9pZCAwLCBbbG9jYWxlLCBrZXldLmNvbmNhdChhcmdzKSk7XG4gIH07IC8vIGNoZWNrIGlmIHRoZSBnaXZlbiBrZXkgZXhpc3RzIGluIHRoZSBjdXJyZW50IGxvY2FsZVxuXG5cbiAgdmFyIGNoZWNrS2V5RXhpc3RzID0gZnVuY3Rpb24gY2hlY2tLZXlFeGlzdHMoa2V5KSB7XG4gICAgdmFyIHNjb3BlID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAnZmFsbGJhY2snO1xuICAgIC8vIGdldCB0aGUgY3VycmVudCBsYW5ndWFnZSBmcm9tIHRoZSBzdG9yZVxuICAgIHZhciBsb2NhbGUgPSBzdG9yZS5zdGF0ZVttb2R1bGVOYW1lXS5sb2NhbGU7XG4gICAgdmFyIGZhbGxiYWNrID0gc3RvcmUuc3RhdGVbbW9kdWxlTmFtZV0uZmFsbGJhY2s7XG4gICAgdmFyIHRyYW5zbGF0aW9ucyA9IHN0b3JlLnN0YXRlW21vZHVsZU5hbWVdLnRyYW5zbGF0aW9uczsgLy8gY2hlY2sgdGhlIGN1cnJlbnQgdHJhbnNsYXRpb25cblxuICAgIGlmICh0cmFuc2xhdGlvbnMuaGFzT3duUHJvcGVydHkobG9jYWxlKSAmJiB0cmFuc2xhdGlvbnNbbG9jYWxlXS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoc2NvcGUgPT0gJ3N0cmljdCcpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IC8vIGNoZWNrIGFueSBsb2NhbGl6ZWQgdHJhbnNsYXRpb25zXG5cblxuICAgIHZhciBsb2NhbGVSZWdpb25hbCA9IGxvY2FsZS5zcGxpdCgnLScpO1xuXG4gICAgaWYgKGxvY2FsZVJlZ2lvbmFsLmxlbmd0aCA+IDEgJiYgdHJhbnNsYXRpb25zLmhhc093blByb3BlcnR5KGxvY2FsZVJlZ2lvbmFsWzBdKSAmJiB0cmFuc2xhdGlvbnNbbG9jYWxlUmVnaW9uYWxbMF1dLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGlmIChzY29wZSA9PSAnbG9jYWxlJykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gLy8gY2hlY2sgaWYgYSBmYWxsYmFjayBsb2NhbGUgZXhpc3RzXG5cblxuICAgIGlmICh0cmFuc2xhdGlvbnMuaGFzT3duUHJvcGVydHkoZmFsbGJhY2spICYmIHRyYW5zbGF0aW9uc1tmYWxsYmFja10uaGFzT3duUHJvcGVydHkoa2V5KSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSAvLyBrZXkgZG9lcyBub3QgZXhpc3QgaW4gdGhlIHN0b3JlXG5cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfTsgLy8gc2V0IGZhbGxiYWNrIGxvY2FsZVxuXG5cbiAgdmFyIHNldEZhbGxiYWNrTG9jYWxlID0gZnVuY3Rpb24gc2V0RmFsbGJhY2tMb2NhbGUobG9jYWxlKSB7XG4gICAgc3RvcmUuZGlzcGF0Y2goe1xuICAgICAgdHlwZTogXCJcIi5jb25jYXQobW9kdWxlTmFtZSwgXCIvc2V0RmFsbGJhY2tMb2NhbGVcIiksXG4gICAgICBsb2NhbGU6IGxvY2FsZVxuICAgIH0pO1xuICB9OyAvLyBzZXQgdGhlIGN1cnJlbnQgbG9jYWxlXG5cblxuICB2YXIgc2V0TG9jYWxlID0gZnVuY3Rpb24gc2V0TG9jYWxlKGxvY2FsZSkge1xuICAgIHN0b3JlLmRpc3BhdGNoKHtcbiAgICAgIHR5cGU6IFwiXCIuY29uY2F0KG1vZHVsZU5hbWUsIFwiL3NldExvY2FsZVwiKSxcbiAgICAgIGxvY2FsZTogbG9jYWxlXG4gICAgfSk7XG4gIH07IC8vIGdldCB0aGUgY3VycmVudCBsb2NhbGVcblxuXG4gIHZhciBnZXRMb2NhbGUgPSBmdW5jdGlvbiBnZXRMb2NhbGUoKSB7XG4gICAgcmV0dXJuIHN0b3JlLnN0YXRlW21vZHVsZU5hbWVdLmxvY2FsZTtcbiAgfTsgLy8gZ2V0IGFsbCBhdmFpbGFibGUgbG9jYWxlc1xuXG5cbiAgdmFyIGdldExvY2FsZXMgPSBmdW5jdGlvbiBnZXRMb2NhbGVzKCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhzdG9yZS5zdGF0ZVttb2R1bGVOYW1lXS50cmFuc2xhdGlvbnMpO1xuICB9OyAvLyBhZGQgcHJlZGVmaW5lZCB0cmFuc2xhdGlvbnMgdG8gdGhlIHN0b3JlIChrZWVwaW5nIGV4aXN0aW5nIGluZm9ybWF0aW9uKVxuXG5cbiAgdmFyIGFkZExvY2FsZSA9IGZ1bmN0aW9uIGFkZExvY2FsZShsb2NhbGUsIHRyYW5zbGF0aW9ucykge1xuICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiBcIlwiLmNvbmNhdChtb2R1bGVOYW1lLCBcIi9hZGRMb2NhbGVcIiksXG4gICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgIHRyYW5zbGF0aW9uczogdHJhbnNsYXRpb25zXG4gICAgfSk7XG4gIH07IC8vIHJlcGxhY2UgYWxsIGxvY2FsZSBpbmZvcm1hdGlvbiBpbiB0aGUgc3RvcmVcblxuXG4gIHZhciByZXBsYWNlTG9jYWxlID0gZnVuY3Rpb24gcmVwbGFjZUxvY2FsZShsb2NhbGUsIHRyYW5zbGF0aW9ucykge1xuICAgIHJldHVybiBzdG9yZS5kaXNwYXRjaCh7XG4gICAgICB0eXBlOiBcIlwiLmNvbmNhdChtb2R1bGVOYW1lLCBcIi9yZXBsYWNlTG9jYWxlXCIpLFxuICAgICAgbG9jYWxlOiBsb2NhbGUsXG4gICAgICB0cmFuc2xhdGlvbnM6IHRyYW5zbGF0aW9uc1xuICAgIH0pO1xuICB9OyAvLyByZW1vdmUgdGhlIGdpdm5lIGxvY2FsZSBmcm9tIHRoZSBzdG9yZVxuXG5cbiAgdmFyIHJlbW92ZUxvY2FsZSA9IGZ1bmN0aW9uIHJlbW92ZUxvY2FsZShsb2NhbGUpIHtcbiAgICBpZiAoc3RvcmUuc3RhdGVbbW9kdWxlTmFtZV0udHJhbnNsYXRpb25zLmhhc093blByb3BlcnR5KGxvY2FsZSkpIHtcbiAgICAgIHN0b3JlLmRpc3BhdGNoKHtcbiAgICAgICAgdHlwZTogXCJcIi5jb25jYXQobW9kdWxlTmFtZSwgXCIvcmVtb3ZlTG9jYWxlXCIpLFxuICAgICAgICBsb2NhbGU6IGxvY2FsZVxuICAgICAgfSk7XG4gICAgfVxuICB9OyAvLyB3ZSBhcmUgcGhhc2luZyBvdXQgdGhlIGV4aXN0cyBmdW5jdGlvblxuXG5cbiAgdmFyIHBoYXNlT3V0RXhpc3RzRm4gPSBmdW5jdGlvbiBwaGFzZU91dEV4aXN0c0ZuKGxvY2FsZSkge1xuICAgIGlmIChjb25maWcud2FybmluZ3MpIGNvbnNvbGUud2FybignaTE4bjogJGkxOG4uZXhpc3RzIGlzIGRlcHJlY2VhdGVkLiBQbGVhc2UgdXNlICRpMThuLmxvY2FsZUV4aXN0cyBpbnN0ZWFkLiBJdCBwcm92aWRlcyBleGFjdGx5IHRoZSBzYW1lIGZ1bmN0aW9uYWxpdHkuJyk7XG4gICAgcmV0dXJuIGNoZWNrTG9jYWxlRXhpc3RzKGxvY2FsZSk7XG4gIH07IC8vIGNoZWNrIGlmIHRoZSBnaXZlbiBsb2NhbGUgaXMgYWxyZWFkeSBsb2FkZWRcblxuXG4gIHZhciBjaGVja0xvY2FsZUV4aXN0cyA9IGZ1bmN0aW9uIGNoZWNrTG9jYWxlRXhpc3RzKGxvY2FsZSkge1xuICAgIHJldHVybiBzdG9yZS5zdGF0ZVttb2R1bGVOYW1lXS50cmFuc2xhdGlvbnMuaGFzT3duUHJvcGVydHkobG9jYWxlKTtcbiAgfTsgLy8gcmVnaXN0ZXIgdnVlIHByb3RvdHlwZSBtZXRob2RzXG5cblxuICBWdWUucHJvdG90eXBlLiRpMThuID0ge1xuICAgIGxvY2FsZTogZ2V0TG9jYWxlLFxuICAgIGxvY2FsZXM6IGdldExvY2FsZXMsXG4gICAgc2V0OiBzZXRMb2NhbGUsXG4gICAgYWRkOiBhZGRMb2NhbGUsXG4gICAgcmVwbGFjZTogcmVwbGFjZUxvY2FsZSxcbiAgICByZW1vdmU6IHJlbW92ZUxvY2FsZSxcbiAgICBmYWxsYmFjazogc2V0RmFsbGJhY2tMb2NhbGUsXG4gICAgbG9jYWxlRXhpc3RzOiBjaGVja0xvY2FsZUV4aXN0cyxcbiAgICBrZXlFeGlzdHM6IGNoZWNrS2V5RXhpc3RzLFxuICAgIHRyYW5zbGF0ZTogdHJhbnNsYXRlLFxuICAgIHRyYW5zbGF0ZUluOiB0cmFuc2xhdGVJbkxhbmd1YWdlLFxuICAgIGV4aXN0czogcGhhc2VPdXRFeGlzdHNGblxuICB9OyAvLyByZWdpc3RlciBnbG9iYWwgbWV0aG9kc1xuXG4gIFZ1ZS5pMThuID0ge1xuICAgIGxvY2FsZTogZ2V0TG9jYWxlLFxuICAgIGxvY2FsZXM6IGdldExvY2FsZXMsXG4gICAgc2V0OiBzZXRMb2NhbGUsXG4gICAgYWRkOiBhZGRMb2NhbGUsXG4gICAgcmVwbGFjZTogcmVwbGFjZUxvY2FsZSxcbiAgICByZW1vdmU6IHJlbW92ZUxvY2FsZSxcbiAgICBmYWxsYmFjazogc2V0RmFsbGJhY2tMb2NhbGUsXG4gICAgdHJhbnNsYXRlOiB0cmFuc2xhdGUsXG4gICAgdHJhbnNsYXRlSW46IHRyYW5zbGF0ZUluTGFuZ3VhZ2UsXG4gICAgbG9jYWxlRXhpc3RzOiBjaGVja0xvY2FsZUV4aXN0cyxcbiAgICBrZXlFeGlzdHM6IGNoZWNrS2V5RXhpc3RzLFxuICAgIGV4aXN0czogcGhhc2VPdXRFeGlzdHNGblxuICB9OyAvLyByZWdpc3RlciB0aGUgdHJhbnNsYXRpb24gZnVuY3Rpb24gb24gdGhlIHZ1ZSBpbnN0YW5jZSBkaXJlY3RseVxuXG4gIFZ1ZS5wcm90b3R5cGUuJHQgPSB0cmFuc2xhdGU7IC8vIHJlZ2lzdGVyIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSB0cmFuc2xhdGlvbiBmdW5jdGlvbiBvbiB0aGUgdnVlIGluc3RhbmNlIGRpcmVjdGx5XG5cbiAgVnVlLnByb3RvdHlwZS4kdGxhbmcgPSB0cmFuc2xhdGVJbkxhbmd1YWdlOyAvLyByZWdpc3RlciBhIGZpbHRlciBmdW5jdGlvbiBmb3IgdHJhbnNsYXRpb25zXG5cbiAgVnVlLmZpbHRlcih0cmFuc2xhdGVGaWx0ZXJOYW1lLCB0cmFuc2xhdGUpO1xuICBWdWUuZmlsdGVyKHRyYW5zbGF0ZUluRmlsdGVyTmFtZSwgdHJhbnNsYXRlSW5MYW5ndWFnZUZpbHRlcik7XG59OyAvLyByZW5kZXJGbiB3aWxsIGluaXRpYWxpemUgYSBmdW5jdGlvbiB0byByZW5kZXIgdGhlIHZhcmlhYmxlIHN1YnN0aXR1dGlvbnMgaW5cbi8vIHRoZSB0cmFuc2xhdGlvbiBzdHJpbmcuIGlkZW50aWZpZXJzIHNwZWNpZnkgdGhlIHRhZ3Mgd2lsbCBiZSB1c2VkIHRvIGZpbmRcbi8vIHZhcmlhYmxlIHN1YnN0aXR1dGlvbnMsIGkuZS4ge3Rlc3R9IG9yIHt7dGVzdH19LCBub3RlIHRoYXQgd2UgYXJlIHVzaW5nIGFcbi8vIGNsb3N1cmUgdG8gYXZvaWQgcmVjb21waWxhdGlvbiBvZiB0aGUgcmVndWxhciBleHByZXNzaW9uIHRvIG1hdGNoIHRhZ3Mgb25cbi8vIGV2ZXJ5IHJlbmRlciBjeWNsZS5cblxuXG52YXIgcmVuZGVyRm4gPSBmdW5jdGlvbiByZW5kZXJGbihpZGVudGlmaWVycykge1xuICB2YXIgd2FybmluZ3MgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRydWU7XG5cbiAgaWYgKGlkZW50aWZpZXJzID09IG51bGwgfHwgaWRlbnRpZmllcnMubGVuZ3RoICE9IDIpIHtcbiAgICBjb25zb2xlLndhcm4oJ2kxOG46IFlvdSBtdXN0IHNwZWNpZnkgdGhlIHN0YXJ0IGFuZCBlbmQgY2hhcmFjdGVyIGlkZW50aWZ5aW5nIHZhcmlhYmxlIHN1YnN0aXR1dGlvbnMnKTtcbiAgfSAvLyBjb25zdHJ1Y3QgYSByZWd1bGFyIGV4cHJlc3Npb24gb3QgZmluZCB2YXJpYWJsZSBzdWJzdGl0dXRpb25zLCBpLmUuIHt0ZXN0fVxuXG5cbiAgdmFyIG1hdGNoZXIgPSBuZXcgUmVnRXhwKCcnICsgaWRlbnRpZmllcnNbMF0gKyAnezF9KFxcXFx3ezF9fFxcXFx3Lis/KScgKyBpZGVudGlmaWVyc1sxXSArICd7MX0nLCAnZycpOyAvLyBkZWZpbmUgdGhlIHJlcGxhY2VtZW50IGZ1bmN0aW9uXG5cbiAgdmFyIHJlcGxhY2UgPSBmdW5jdGlvbiByZXBsYWNlKHRyYW5zbGF0aW9uLCByZXBsYWNlbWVudHMpIHtcbiAgICAvLyBjaGVjayBpZiB0aGUgb2JqZWN0IGhhcyBhIHJlcGxhY2UgcHJvcGVydHlcbiAgICBpZiAoIXRyYW5zbGF0aW9uLnJlcGxhY2UpIHtcbiAgICAgIHJldHVybiB0cmFuc2xhdGlvbjtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJhbnNsYXRpb24ucmVwbGFjZShtYXRjaGVyLCBmdW5jdGlvbiAocGxhY2Vob2xkZXIpIHtcbiAgICAgIC8vIHJlbW92ZSB0aGUgaWRlbnRpZmllcnMgKGNhbiBiZSBzZXQgb24gdGhlIG1vZHVsZSBsZXZlbClcbiAgICAgIHZhciBrZXkgPSBwbGFjZWhvbGRlci5yZXBsYWNlKGlkZW50aWZpZXJzWzBdLCAnJykucmVwbGFjZShpZGVudGlmaWVyc1sxXSwgJycpO1xuXG4gICAgICBpZiAocmVwbGFjZW1lbnRzW2tleV0gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gcmVwbGFjZW1lbnRzW2tleV07XG4gICAgICB9IC8vIHdhcm4gdXNlciB0aGF0IHRoZSBwbGFjZWhvbGRlciBoYXMgbm90IGJlZW4gZm91bmRcblxuXG4gICAgICBpZiAod2FybmluZ3MpIHtcbiAgICAgICAgY29uc29sZS5ncm91cCA/IGNvbnNvbGUuZ3JvdXAoJ2kxOG46IE5vdCBhbGwgcGxhY2Vob2xkZXJzIGZvdW5kJykgOiBjb25zb2xlLndhcm4oJ2kxOG46IE5vdCBhbGwgcGxhY2Vob2xkZXJzIGZvdW5kJyk7XG4gICAgICAgIGNvbnNvbGUud2FybignVGV4dDonLCB0cmFuc2xhdGlvbik7XG4gICAgICAgIGNvbnNvbGUud2FybignUGxhY2Vob2xkZXI6JywgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIGlmIChjb25zb2xlLmdyb3VwRW5kKSB7XG4gICAgICAgICAgY29uc29sZS5ncm91cEVuZCgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIHJldHVybiB0aGUgb3JpZ2luYWwgcGxhY2Vob2xkZXJcblxuXG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXI7XG4gICAgfSk7XG4gIH07IC8vIHRoZSByZW5kZXIgZnVuY3Rpb24gd2lsbCByZXBsYWNlIHZhcmlhYmxlIHN1YnN0aXR1dGlvbnMgYW5kIHByZXBhcmUgdGhlXG4gIC8vIHRyYW5zbGF0aW9ucyBmb3IgcmVuZGVyaW5nXG5cblxuICB2YXIgcmVuZGVyID0gZnVuY3Rpb24gcmVuZGVyKGxvY2FsZSwgdHJhbnNsYXRpb24pIHtcbiAgICB2YXIgcmVwbGFjZW1lbnRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICB2YXIgcGx1cmFsaXphdGlvbiA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcblxuICAgIC8vIGdldCB0aGUgdHlwZSBvZiB0aGUgcHJvcGVydHlcbiAgICB2YXIgb2JqVHlwZSA9IF90eXBlb2YodHJhbnNsYXRpb24pO1xuXG4gICAgdmFyIHBsdXJhbGl6YXRpb25UeXBlID0gX3R5cGVvZihwbHVyYWxpemF0aW9uKTtcblxuICAgIHZhciByZXNvbHZlUGxhY2Vob2xkZXJzID0gZnVuY3Rpb24gcmVzb2x2ZVBsYWNlaG9sZGVycygpIHtcbiAgICAgIGlmIChpc0FycmF5JDEodHJhbnNsYXRpb24pKSB7XG4gICAgICAgIC8vIHJlcGxhY2UgdGhlIHBsYWNlaG9sZGVyIGVsZW1lbnRzIGluIGFsbCBzdWItaXRlbXNcbiAgICAgICAgcmV0dXJuIHRyYW5zbGF0aW9uLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICAgIHJldHVybiByZXBsYWNlKGl0ZW0sIHJlcGxhY2VtZW50cywgZmFsc2UpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSBpZiAob2JqVHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHJlcGxhY2UodHJhbnNsYXRpb24sIHJlcGxhY2VtZW50cywgdHJ1ZSk7XG4gICAgICB9XG4gICAgfTsgLy8gcmV0dXJuIHRyYW5zbGF0aW9uIGl0ZW0gZGlyZWN0bHlcblxuXG4gICAgaWYgKHBsdXJhbGl6YXRpb24gPT09IG51bGwpIHtcbiAgICAgIHJldHVybiByZXNvbHZlUGxhY2Vob2xkZXJzKCk7XG4gICAgfSAvLyBjaGVjayBpZiBwbHVyYWxpemF0aW9uIHZhbHVlIGlzIGNvdW50YWJsZVxuXG5cbiAgICBpZiAocGx1cmFsaXphdGlvblR5cGUgIT09ICdudW1iZXInKSB7XG4gICAgICBpZiAod2FybmluZ3MpIGNvbnNvbGUud2FybignaTE4bjogcGx1cmFsaXphdGlvbiBpcyBub3QgYSBudW1iZXInKTtcbiAgICAgIHJldHVybiByZXNvbHZlUGxhY2Vob2xkZXJzKCk7XG4gICAgfSAvLyAtLS0gaGFuZGxlIHBsdXJhbGl6YXRpb25zIC0tLVxuICAgIC8vIHJlcGxhY2UgYWxsIHBsYWNlaG9sZGVyc1xuXG5cbiAgICB2YXIgcmVzb2x2ZWRUcmFuc2xhdGlvbiA9IHJlc29sdmVQbGFjZWhvbGRlcnMoKTsgLy8gaW5pdGlhbGl6ZSBwbHVyYWxpemF0aW9uc1xuXG4gICAgdmFyIHBsdXJhbGl6YXRpb25zID0gbnVsbDsgLy8gaWYgdHJhbnNsYXRpb25zIGFyZSBhbHJlYWR5IGFuIGFycmF5IGFuZCBoYXZlIG1vcmUgdGhhbiBvbmUgZW50cnksXG4gICAgLy8gd2Ugd2lsbCBub3QgcGVyZm9ybSBhIHNwbGl0IG9wZXJhdGlvbiBvbiA6OjpcblxuICAgIGlmIChpc0FycmF5JDEocmVzb2x2ZWRUcmFuc2xhdGlvbikgJiYgcmVzb2x2ZWRUcmFuc2xhdGlvbi5sZW5ndGggPiAwKSB7XG4gICAgICBwbHVyYWxpemF0aW9ucyA9IHJlc29sdmVkVHJhbnNsYXRpb247XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHNwbGl0IHRyYW5zbGF0aW9uIHN0cmluZ3MgYnkgOjo6IHRvIGZpbmQgY3JlYXRlIHRoZSBwbHVyYWxpemF0aW9uIGFycmF5XG4gICAgICBwbHVyYWxpemF0aW9ucyA9IHJlc29sdmVkVHJhbnNsYXRpb24uc3BsaXQoJzo6OicpO1xuICAgIH0gLy8gZGV0ZXJtaW5lIHRoZSBwbHVyYWxpemF0aW9uIHZlcnNpb24gdG8gdXNlIGJ5IGxvY2FsZVxuXG5cbiAgICB2YXIgaW5kZXggPSBwbHVyYWxzLmdldFRyYW5zbGF0aW9uSW5kZXgobG9jYWxlLCBwbHVyYWxpemF0aW9uKTsgLy8gY2hlY2sgaWYgdGhlIHNwZWNpZmllZCBpbmRleCBpcyBwcmVzZW50IGluIHRoZSBwbHVyYWxpemF0aW9uXG5cbiAgICBpZiAodHlwZW9mIHBsdXJhbGl6YXRpb25zW2luZGV4XSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmICh3YXJuaW5ncykge1xuICAgICAgICBjb25zb2xlLndhcm4oJ2kxOG46IHBsdXJhbGl6YXRpb24gbm90IHByb3ZpZGVkIGluIGxvY2FsZScsIHRyYW5zbGF0aW9uLCBsb2NhbGUsIGluZGV4KTtcbiAgICAgIH0gLy8gcmV0dXJuIHRoZSBmaXJzdCBlbGVtZW50IG9mIHRoZSBwbHVyYWxpemF0aW9uIGJ5IGRlZmF1bHRcblxuXG4gICAgICByZXR1cm4gcGx1cmFsaXphdGlvbnNbMF0udHJpbSgpO1xuICAgIH0gLy8gcmV0dXJuIHRoZSByZXF1ZXN0ZWQgaXRlbSBmcm9tIHRoZSBwbHVyYWxpemF0aW9uc1xuXG5cbiAgICByZXR1cm4gcGx1cmFsaXphdGlvbnNbaW5kZXhdLnRyaW0oKTtcbiAgfTsgLy8gcmV0dXJuIHRoZSByZW5kZXIgZnVuY3Rpb24gdG8gdGhlIGNhbGxlclxuXG5cbiAgcmV0dXJuIHJlbmRlcjtcbn07IC8vIGNoZWNrIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgYW4gYXJyYXlcblxuXG5mdW5jdGlvbiBpc0FycmF5JDEob2JqKSB7XG4gIHJldHVybiAhIW9iaiAmJiBBcnJheSA9PT0gb2JqLmNvbnN0cnVjdG9yO1xufVxuXG4vLyBpbXBvcnQgdGhlIHZ1ZXggbW9kdWxlIGZvciBsb2NhbGl6YXRpb25cblxudmFyIGluZGV4ID0ge1xuICBzdG9yZTogaTE4blZ1ZXhNb2R1bGUsXG4gIHBsdWdpbjogVnVleEkxOG5QbHVnaW5cbn07XG5cbmV4cG9ydCBkZWZhdWx0IGluZGV4O1xuIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///../../node_modules/vuex-i18n/dist/vuex-i18n.es.js\n");

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var dapp_browser__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! dapp-browser */ \"dapp-browser\");\n/* harmony import */ var dapp_browser__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(dapp_browser__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var vuex_i18n__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! vuex-i18n */ \"../../node_modules/vuex-i18n/dist/vuex-i18n.es.js\");\n/*\n  Copyright (C) 2018-present evan GmbH.\n\n  This program is free software: you can redistribute it and/or modify it\n  under the terms of the GNU Affero General Public License, version 3,\n  as published by the Free Software Foundation.\n\n  This program is distributed in the hope that it will be useful,\n  but WITHOUT ANY WARRANTY; without even the implied warranty of\n  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n  See the GNU Affero General Public License for more details.\n\n  You should have received a copy of the GNU Affero General Public License\n  along with this program. If not, see http://www.gnu.org/licenses/ or\n  write to the Free Software Foundation, Inc., 51 Franklin Street,\n  Fifth Floor, Boston, MA, 02110-1301 USA, or download the license from\n  the following URL: https://evan.network/license/\n\n  You can be released from the requirements of the GNU Affero General Public\n  License by purchasing a commercial license.\n  Buying such a license is mandatory as soon as you use this software or parts\n  of it on other blockchains than evan.network.\n\n  For more information, please contact evan GmbH at this address:\n  https://evan.network/license/\n*/\n// map the original vue path to i18n.vuex.libs\n\ndapp_browser__WEBPACK_IMPORTED_MODULE_0__[\"System\"].map['vuex-i18n'] = \"i18n.vuex.libs.\" + Object(dapp_browser__WEBPACK_IMPORTED_MODULE_0__[\"getDomainName\"])() + \"!dapp-content\";\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (vuex_i18n__WEBPACK_IMPORTED_MODULE_1__[\"default\"]);\n\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pMThuLnZ1ZXgubGlicy5qcy8uL3NyYy9pbmRleC50cz9mZmI0Il0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7RUF5QkU7QUFDRiw4Q0FBOEM7QUFDTztBQUNyRCxtREFBTSxDQUFDLEdBQUcsQ0FBQyxXQUFXLENBQUMsR0FBRyxvQkFBbUIsa0VBQWEsRUFBRSxrQkFBZ0IsQ0FBQztBQUU1QztBQUNsQixnSEFBUSxFQUFDIiwiZmlsZSI6Ii4vc3JjL2luZGV4LnRzLmpzIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiAgQ29weXJpZ2h0IChDKSAyMDE4LXByZXNlbnQgZXZhbiBHbWJILlxuXG4gIFRoaXMgcHJvZ3JhbSBpcyBmcmVlIHNvZnR3YXJlOiB5b3UgY2FuIHJlZGlzdHJpYnV0ZSBpdCBhbmQvb3IgbW9kaWZ5IGl0XG4gIHVuZGVyIHRoZSB0ZXJtcyBvZiB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlLCB2ZXJzaW9uIDMsXG4gIGFzIHB1Ymxpc2hlZCBieSB0aGUgRnJlZSBTb2Z0d2FyZSBGb3VuZGF0aW9uLlxuXG4gIFRoaXMgcHJvZ3JhbSBpcyBkaXN0cmlidXRlZCBpbiB0aGUgaG9wZSB0aGF0IGl0IHdpbGwgYmUgdXNlZnVsLFxuICBidXQgV0lUSE9VVCBBTlkgV0FSUkFOVFk7IHdpdGhvdXQgZXZlbiB0aGUgaW1wbGllZCB3YXJyYW50eSBvZlxuICBNRVJDSEFOVEFCSUxJVFkgb3IgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UuXG4gIFNlZSB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlIGZvciBtb3JlIGRldGFpbHMuXG5cbiAgWW91IHNob3VsZCBoYXZlIHJlY2VpdmVkIGEgY29weSBvZiB0aGUgR05VIEFmZmVybyBHZW5lcmFsIFB1YmxpYyBMaWNlbnNlXG4gIGFsb25nIHdpdGggdGhpcyBwcm9ncmFtLiBJZiBub3QsIHNlZSBodHRwOi8vd3d3LmdudS5vcmcvbGljZW5zZXMvIG9yXG4gIHdyaXRlIHRvIHRoZSBGcmVlIFNvZnR3YXJlIEZvdW5kYXRpb24sIEluYy4sIDUxIEZyYW5rbGluIFN0cmVldCxcbiAgRmlmdGggRmxvb3IsIEJvc3RvbiwgTUEsIDAyMTEwLTEzMDEgVVNBLCBvciBkb3dubG9hZCB0aGUgbGljZW5zZSBmcm9tXG4gIHRoZSBmb2xsb3dpbmcgVVJMOiBodHRwczovL2V2YW4ubmV0d29yay9saWNlbnNlL1xuXG4gIFlvdSBjYW4gYmUgcmVsZWFzZWQgZnJvbSB0aGUgcmVxdWlyZW1lbnRzIG9mIHRoZSBHTlUgQWZmZXJvIEdlbmVyYWwgUHVibGljXG4gIExpY2Vuc2UgYnkgcHVyY2hhc2luZyBhIGNvbW1lcmNpYWwgbGljZW5zZS5cbiAgQnV5aW5nIHN1Y2ggYSBsaWNlbnNlIGlzIG1hbmRhdG9yeSBhcyBzb29uIGFzIHlvdSB1c2UgdGhpcyBzb2Z0d2FyZSBvciBwYXJ0c1xuICBvZiBpdCBvbiBvdGhlciBibG9ja2NoYWlucyB0aGFuIGV2YW4ubmV0d29yay5cblxuICBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgcGxlYXNlIGNvbnRhY3QgZXZhbiBHbWJIIGF0IHRoaXMgYWRkcmVzczpcbiAgaHR0cHM6Ly9ldmFuLm5ldHdvcmsvbGljZW5zZS9cbiovXG4vLyBtYXAgdGhlIG9yaWdpbmFsIHZ1ZSBwYXRoIHRvIGkxOG4udnVleC5saWJzXG5pbXBvcnQgeyBTeXN0ZW0sIGdldERvbWFpbk5hbWUgfSBmcm9tICdkYXBwLWJyb3dzZXInO1xuU3lzdGVtLm1hcFsndnVleC1pMThuJ10gPSBgaTE4bi52dWV4LmxpYnMuJHsgZ2V0RG9tYWluTmFtZSgpIH0hZGFwcC1jb250ZW50YDtcblxuaW1wb3J0IHZ1ZXhJMThuIGZyb20gJ3Z1ZXgtaTE4bic7XG5leHBvcnQgZGVmYXVsdCB2dWV4STE4bjtcbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./src/index.ts\n");

/***/ }),

/***/ "dapp-browser":
/*!*******************************!*\
  !*** external "dapp-browser" ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports) {

eval("module.exports = __WEBPACK_EXTERNAL_MODULE_dapp_browser__;\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9pMThuLnZ1ZXgubGlicy5qcy9leHRlcm5hbCBcImRhcHAtYnJvd3NlclwiPzRkYzgiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEiLCJmaWxlIjoiZGFwcC1icm93c2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSBfX1dFQlBBQ0tfRVhURVJOQUxfTU9EVUxFX2RhcHBfYnJvd3Nlcl9fOyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///dapp-browser\n");

/***/ })

/******/ });
});